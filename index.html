<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Eagle View Designer</title>

  <!-- html2canvas for JPG Export -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <!-- ExcelJS for ID export -->
  <script src="https://cdn.jsdelivr.net/npm/exceljs@4.3.0/dist/exceljs.min.js"></script>

  <style>
    /**********************************************
     * GLOBAL & LAYOUT (HTML)
    **********************************************/
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
    }
    body {
      display: flex;
      flex-direction: column;
      font-family: Arial, sans-serif;
      overflow: hidden; /* Prevent body scroll */
      user-select: none; /* no text selection */
    }

    /* =========================
       TOP BAR
    ========================= */
    .top-bar {
      width: 100%;
      background-color: #14335D;
      color: #fff;
      height: 48px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 1rem;
      box-sizing: border-box;
      flex-shrink: 0;
    }
    .bar-left {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .bar-left img {
      width: 32px; 
      height: 32px;
      object-fit: cover;
      border-radius: 50%;
    }
    .bar-title {
      font-size: 1.2rem;
    }
    .bar-actions {
      display: flex;
      gap: 0.5rem;
    }
    .bar-actions button {
      cursor: pointer;
      background-color: #eee;
      color: #000;
      border: 1px solid #999;
      padding: 0.4rem 0.8rem;
      font-size: 0.9rem;
      border-radius: 4px;
      transition: background-color 0.2s;
    }
    .bar-actions button:hover {
      background-color: #ddd;
    }

    /* =========================
       MAIN BODY WRAPPER
    ========================= */
    .body-wrapper {
      display: flex;
      flex-direction: row; /* Align sidebar and main content horizontally */
      flex: 1;
      position: relative;
      overflow: hidden; 
      min-height: 0; /* Important for flex children to shrink properly */
    }

    /* =========================
       SIDEBAR
    ========================= */
    .sidebar {
      width: 300px;
      background-color: #14335D;
      color: #fff;
      transition: width 0.3s ease;
      overflow-y: auto;
      padding: 1rem;
      box-sizing: border-box;
      min-height: 0; /* Important for flex children to shrink properly */
    }
    .sidebar.collapsed {
      width: 40px;
      padding: 1rem 0;
    }
    .sidebar.collapsed .sidebar-header h2,
    .sidebar.collapsed .menu-section,
    .sidebar.collapsed .toggle-section {
      display: none;
    }
    /* Hide Facility Number when collapsed */
    .sidebar.collapsed .facility-inline {
      display: none !important;
    }

    .sidebar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
    }
    .sidebar.collapsed .sidebar-header {
      justify-content: center;
    }
    .collapse-icon {
      font-size: 1.2rem;
    }
    .menu-section {
      margin-top: 1rem;
    }
    .menu-title {
      background-color: #2b476d;
      padding: 0.2rem 0.4rem;
      line-height: 1.2;
      font-size: 0.9rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      user-select: none;
      border-radius: 4px;
    }
    .menu-title:hover {
      background-color: #3b5a8d;
    }
    .menu-content {
      background-color: #2b476d;
      padding: 0.5rem;
      display: none;
      border-radius: 4px;
      margin-top: 0.3rem;
    }
    .menu-content label,
    .menu-content input,
    .menu-content select,
    .menu-content button {
      display: block;
      margin: 0.3rem 0;
    }
    .menu-content button {
      cursor: pointer;
      background-color: #eee;
      color: #000;
      border: 1px solid #999;
      padding: 0.4rem 0.8rem;
      font-size: 0.9rem;
      border-radius: 4px;
      transition: background-color 0.2s;
    }
    .menu-content button:hover {
      background-color: #ddd;
    }

    .facility-inline {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin: 0.5rem 0;
    }
    .facility-inline label {
      margin: 0;
    }
    .facility-inline input {
      width: 60px; /* shrink to fit same line */
    }

    /* Slight highlight for the Zone Name block */
    .zone-name-block {
      background-color: #1b4c88;
      padding: 0.5rem;
      border-radius: 4px;
      margin-bottom: 0.5rem;
    }
    .zone-name-block label {
      margin: 0.3rem 0;
    }
    .zone-name-block input {
      margin-top: 0.2rem;
    }

    /* =========================
       TOGGLE SECTIONS (Snap/Trash)
    ========================= */
    .toggle-section {
      margin-top: 1rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      position: relative;
    }
    .toggle-section label {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.9rem;
    }

    /* =========================
       ON/OFF Toggle Switch
    ========================= */
    .switch {
      position: relative;
      display: inline-block;
      width: 34px;
      height: 18px;
    }
    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0; 
      left: 0; 
      right: 0; 
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 18px;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 12px;
      width: 12px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    input:checked + .slider {
      background-color: #2196F3;
    }
    input:focus + .slider {
      box-shadow: 0 0 1px #2196F3;
    }
    input:checked + .slider:before {
      transform: translateX(16px);
    }

    /* =========================
       SVG WRAPPER
    ========================= */
    .svg-wrapper {
      position: relative;
      margin: 1rem;
      width: 1046.5px; 
      height: 500px;
      border: 2px solid #444;
      box-sizing: content-box;
      overflow: hidden;
      flex-shrink: 0; /* Prevent shrinking when the main-content grows */
    }

    /*
      Classes toggled for export cleanup
      (applied for both JPG & SVG export)
    */
    .no-border {
      border: none !important;
    }
    .no-buttons .trash-can {
      display: none !important;
    }
    .no-grid #canvasSVG .grid-rect {
      display: none !important;
    }
    .no-grid #canvasSVG .grid-overlay {
      display: none !important;
    }
    .export-cleanup g[data-type="draggable"] {
      cursor: auto !important; 
    }
    /* We'll hide any elements with 'data-export-ignore' in the final export */
    .export-cleanup [data-export-ignore] {
      display: none !important;
    }

    /* =========================
       TRASH CAN (HTML-based)
    ========================= */
    .trash-can {
      position: absolute;
      bottom: 10px;
      right: 10px;
      width: 48px;
      height: 48px;
      z-index: 9999;
      transition: transform 0.2s ease;
    }
    .trash-can img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    /* =========================
       ANIMATIONS
    ========================= */
    @keyframes vibrate {
      0% { transform: translate(0,0); }
      20% { transform: translate(-2px, 0); }
      40% { transform: translate(2px, 0); }
      60% { transform: translate(-2px, 0); }
      80% { transform: translate(2px, 0); }
      100% { transform: translate(0,0); }
    }
    .vibrate {
      animation: vibrate 0.3s ease-in-out;
    }
    .puff-overlay {
      position: absolute;
      width: 50px;
      height: 50px;
      font-size: 24px;
      text-align: center;
      align-items: center;
      justify-content: center;
      display: flex;
      z-index: 11000;
      pointer-events: none;
    }
    .fade-out {
      animation: fadeOut 0.8s forwards;
    }
    @keyframes fadeOut {
      0% { opacity: 1; }
      100% { opacity: 0; }
    }

    /* Show the resize cursor on the corner handle */
    [data-resize="corner"] {
      cursor: nwse-resize;
    }

    /* =========================
       FOOTER
    ========================= */
    .footer {
      text-align: center;
      font-size: 0.8rem;
      color: #666;
      padding: 0.5rem 0;
      background-color: #f1f1f1;
      flex-shrink: 0;
    }
    .footer a {
      color: #666;
      text-decoration: none;
    }
    .footer a:hover {
      text-decoration: underline;
    }

    /* =========================
       TOOLTIP STYLES
    ========================= */
    .tooltip-container {
      display: inline-block;
      position: relative;
      margin-left: 4px;
      cursor: pointer;
      font-size: 0.8em;
      color: #aaaaaa; /* subtle */
    }
    .tooltip-container::after {
      content: ' \24D8'; /* "i" in a circle (Unicode U+24D8) */
      font-weight: normal;
      margin-left: 0px;
    }
    .tooltip-text {
      visibility: hidden;
      width: 200px;
      background-color: #444;
      color: #fff;
      text-align: center;
      border-radius: 4px;
      padding: 0.5rem;
      position: absolute;
      z-index: 10;
      bottom: 130%;
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      transition: opacity 0.2s;
      font-size: 0.8rem;
    }
    .tooltip-container:hover .tooltip-text {
      visibility: visible;
      opacity: 1;
    }
    .tooltip-text::after {
      content: "";
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border-width: 6px;
      border-style: solid;
      border-color: #444 transparent transparent transparent;
    }

    /* Small preview image for custom image selection */
    #customImagePreview {
      display: none;
      width: 36px;
      height: 36px;
      margin-left: 0.5rem;
      object-fit: contain;
      border: 1px solid #999;
      background-color: #fff;
    }

    /* =========================
       TRIANGLES
    ========================= */
    .loading_triangle {
      fill: #FFA500;
      display: none;
    }
    .unloading_triangle {
      fill: #30C230;
      display: none;
    }

    /* =========================
       (UPDATED) Label Text
       Removed fill: #fff so user-selected color is honored
    ========================= */
    .label-text {
      /* no fill here (will be set inline) */
      font-family: Helvetica, sans-serif;
      pointer-events: none; /* for smoother dragging */
    }

    /* =========================
       NEW: Tooltip Styles for Label Rotation
    ========================= */
    .rotation-tooltip {
      margin-left: 4px;
    }

    /* =========================
       NEW FEATURE: Zones Table
    ========================= */
    .zones-table-wrapper {
      margin: 1rem;
      border: 2px solid #444;
      border-radius: 4px;
      background-color: #2b476d;
      color: #fff;
      width: 1046.5px; /* Same width as the SVG Canvas */
      max-height: 300px;
      overflow: auto;
      box-sizing: border-box;
      flex-shrink: 0;
    }
    .zones-table-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: #3b5a8d;
      padding: 0.5rem;
      cursor: pointer;
      user-select: none;
      border-top-left-radius: 4px;
      border-top-right-radius: 4px;
    }
    .zones-table-header h3 {
      margin: 0;
      font-size: 1rem;
    }
    .zones-table-header .collapse-icon {
      font-size: 1rem;
      transition: transform 0.3s;
    }
    .zones-table-content {
      padding: 0.5rem;
      display: none;
    }
    .zones-table-content table {
      width: 100%;
      border-collapse: collapse;
    }
    .zones-table-content th, .zones-table-content td {
      border: 1px solid #fff;
      padding: 0.3rem;
      text-align: center;
      font-size: 0.9rem;
    }
    .zones-table-content tr:hover {
      background-color: #4a6fa5;
      cursor: pointer;
    }
    /* Highlighted elements */
    .highlighted {
      stroke: yellow;
      stroke-width: 2;
    }

    /* =========================
       LAYERS SIDEBAR
    ========================= */
    .layers-sidebar {
      width: 220px;
      background-color: #14335D;
      color: #fff;
      overflow-y: auto;
      box-sizing: border-box;
      transition: transform 0.3s ease;
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      position: relative;
    }
    .layers-sidebar.collapsed {
      transform: translateX(100%);
    }
    .layers-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: #2b476d;
      padding: 0.5rem;
      cursor: pointer;
      user-select: none;
    }
    #layersList {
      list-style: none;
      margin: 0;
      padding: 0.5rem;
    }
    #layersList li {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.3rem;
      border: 1px solid #4a6fa5;
      margin-bottom: 0.3rem;
      background-color: #2b476d;
      cursor: grab;
      user-select: none;
    }
    #layersList li .layer-name {
      flex: 1;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
    }

    #layerContextMenu {
      position: absolute;
      background-color: #2b476d;
      color: #fff;
      border: 1px solid #444;
      list-style: none;
      padding: 0;
      margin: 0;
      display: none;
      z-index: 1000;
    }
    #layerContextMenu li {
      padding: 0.4rem 0.8rem;
      cursor: pointer;
    }
    #layerContextMenu li:hover {
      background-color: #3b5a8d;
    }

    /* =========================
       MAIN CONTENT
    ========================= */
    .main-content {
      display: flex;
      flex-direction: column;
      flex: 1;
      overflow: auto;
      min-height: 0; /* Important for flex children to shrink properly */
      align-items: center; /* Center the Zones List horizontally */
    }

    /* =========================
       RESPONSIVE DESIGN
    ========================= */
    @media (max-width: 1200px) {
      .svg-wrapper {
        width: 80vw;
        height: 40vh;
      }
      .zones-table-wrapper {
        width: 80vw;
      }
    }
    @media (max-width: 800px) {
      .body-wrapper {
        flex-direction: column;
      }
      .sidebar {
        width: 100%;
        height: 200px;
        overflow-y: scroll;
      }
      .svg-wrapper {
        width: 100%;
        height: 300px;
      }
      .zones-table-wrapper {
        width: 100%;
        max-height: 200px;
      }
    }

    /* =========================
       COUNTERS STYLING
    ========================= */
    /* Updated Counters Styling */
    .counters {
      display: flex;
      gap: 1rem;
      margin-right: 1rem; /* Maintains space between counters and buttons */
      align-items: center; /* Vertically centers the counters with the buttons */
    }

    .counters span {
      padding: 0.3rem 0.8rem;
      font-weight: 500; 
      font-size: 14px;
      color: #eeeeee;
      white-space: nowrap; /* Prevents text from wrapping */
      background-color: #14335D;
      border: 1px solid #e0e0e0; /* Light border */
      cursor: default;
    }

    /* Optional: Add a slight hover effect for better UX without implying interactivity */
    .counters span:hover {
      background-color: #2b6cc6; /* Ensures no background appears on hover */
      color: #eeeeee;
    }

    .counters::after {
      content: "";
      display: inline-block;
      width: 1px;
      height: 20px;
      background-color: #ccc;
    }

    /* Undo Button Styling */
    #undoBtn {
      background: transparent;
      border: none;
      cursor: pointer;
      padding: 0.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background-color 0.2s, transform 0.2s;
      border-radius: 4px; /* Optional: Adds slight rounding on hover */
    }

    #undoBtn:hover {
      background-color: rgba(255, 255, 255, 0.1);
      transform: scale(1.05); /* Optional: Slightly enlarges on hover */
    }

    #undoBtn svg {
      fill: #eeeeee;
      width: 16px;
      height: 16px;
    }
    #undoBtn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

  </style>
</head>
<body onselectstart="return false;">

  <!-- TOP BAR -->
  <div class="top-bar">
    <div class="bar-left">
      <img src="https://i.imgur.com/U0zTNSu.png" alt="YMS Logo" />
      <div class="bar-title">Eagle View Designer</div>
    </div>
    <div class="bar-actions" style="display: flex; align-items: center; gap: 1rem;">
      <!-- Counters Container -->
      <div id="counters" class="counters" style="display: flex; gap: 1rem; margin-right: auto;">
        <button id="undoBtn" title="Undo (CTRL/CMD-Z)" aria-label="Undo">
          <!-- Undo Icon (SVG) -->
          <svg width="16" height="16" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 5V1L8 5l4 4V6c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/>
          </svg>
        </button>
        <span id="totalSpots">Spots: 0</span>
        <span id="totalDocks">Docks: 0</span>
      </div>
      
      <!-- Export Buttons -->
      <button id="exportJpgBtn">Export as JPG</button>
      <button id="exportSvgBtn">Export as SVG</button>
    </div>
  </div>


  <!-- MAIN CONTENT WRAPPER -->
  <div class="body-wrapper">
    <!-- SIDEBAR -->
    <div class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <h2>Tools</h2>
        <span class="collapse-icon" id="collapseIcon">‚ò∞</span>
      </div>

      <!-- FACILITY ID INPUT (inline) -->
      <div class="facility-inline">
        <label for="facilityNumberInput" style="white-space: nowrap;">
          #Ô∏è‚É£ Facility Number:
        </label>
        <span class="tooltip-container">
          <span class="tooltip-text">
            Please enter which facility this is. For example, if this is the second facility being implemented, enter "2".
          </span>
        </span>
        <input id="facilityNumberInput" type="number" value="1" min="1" />
      </div>

      <!-- STARTING ZONE NUMBER INPUT (inline) -->
      <div class="facility-inline">
        <label for="startingZoneNumberInput" style="white-space: nowrap;">
          #Ô∏è‚É£ Starting Zone #:
        </label>
        <span class="tooltip-container">
          <span class="tooltip-text">
            Enter the zone number you want to start from. Changing this value will renumber all existing zones.
          </span>
        </span>
        <input id="startingZoneNumberInput" type="number" value="1" min="1" />
      </div>

      <!-- Snap to Grid Toggle Section -->
      <div class="toggle-section">
        <label for="snapToGridToggle">üî≥ Snap to Grid</label>
        <label class="switch">
          <input type="checkbox" id="snapToGridToggle">
          <span class="slider"></span>
        </label>
      </div>

      <!-- Magnetize Toggle Section -->
      <div class="toggle-section">
        <label for="magnetizeToggle">üß≤ Magnetize</label>
        <label class="switch">
          <input type="checkbox" id="magnetizeToggle">
          <span class="slider"></span>
        </label>
      </div>


      <!-- Hide Trash Toggle Section -->
      <div class="toggle-section">
        <label for="hideTrashToggle">üóëÔ∏è Hide Trash</label>
        <label class="switch">
          <input type="checkbox" id="hideTrashToggle">
          <span class="slider"></span>
        </label>
      </div>

      <!-- YARD SPOTS -->
      <div class="menu-section">
        <div class="menu-title" data-target="yardSpotsContent">
          <h3>Yard Spots</h3><span class="collapse-icon">‚ñº</span>
        </div>
        <div class="menu-content" id="yardSpotsContent">

          <!-- Zone Name (at top, subtly highlighted) -->
          <div class="zone-name-block">
            <label>
              Zone Name:
              <span class="tooltip-container">
                <span class="tooltip-text">
                  This is not displayed on Eagle View. Zones are for grouping spots in the system.
                </span>
              </span>
            </label>
            <input id="yardSpotZoneName" type="text" placeholder="(Required) Enter Zone Name" />
          </div>

          <label>Number of Spots:</label>
          <input id="yardSpotCount" type="number" value="3" min="1"/>

          <label>Orientation:</label>
          <select id="yardSpotOrientation">
            <option value="horizontal">Horizontal</option>
            <option value="vertical">Vertical</option>
          </select>

          <label>Show Numbers?</label>
          <select id="yardSpotShowNumbers">
            <option value="yes">Yes</option>
            <option value="no">No</option>
          </select>

          <div id="yardSpotNumbersContainer">
            <label>Start Numbering At:</label>
            <input id="yardSpotStartNumber" type="number" value="1" min="1" />

            <label>Direction of Numbering:</label>
            <select id="yardSpotNumberDirection"></select>

            <label>Label Location:</label>
            <select id="yardSpotLabelLocation"></select>

            <!-- NEW: Label Rotation & Tooltip -->
            <label id="yardSpotLabelRotationLabel" style="display:none;">
              Label Rotation:
              <span class="tooltip-container rotation-tooltip">
                <span class="tooltip-text" id="yardSpotLabelRotationTooltip">
                  Select how labels are rotated.
                </span>
              </span>
            </label>
            <select id="yardSpotLabelRotation" style="display:none;">
              <option value="dynamic">Dynamic</option>
              <option value="90">All 90¬∞</option>
              <option value="none">None</option>
            </select>

            <label>Add Prefix/Suffix?</label>
            <select id="yardSpotPrefixSuffixDropdown">
              <option value="no">No</option>
              <option value="yes">Yes</option>
            </select>

            <div id="yardSpotPrefixSuffixContainer" style="display:none;">
              <label>Spot Prefix:</label>
              <input id="yardSpotPrefix" type="text" placeholder="e.g. A"/>
              <label>Spot Suffix:</label>
              <input id="yardSpotSuffix" type="text" placeholder="e.g. Z"/>
            </div>
          </div>

          <button id="addYardSpotsBtn" style="margin-top:1rem;">Add Spots</button>
        </div>
      </div>

      <!-- DOCK DOORS -->
      <div class="menu-section">
        <div class="menu-title" data-target="dockDoorsContent">
          <h3>Dock Doors</h3><span class="collapse-icon">‚ñº</span>
        </div>
        <div class="menu-content" id="dockDoorsContent">

          <!-- Zone Name (at top, subtly highlighted) -->
          <div class="zone-name-block">
            <label>
              Zone Name:
              <span class="tooltip-container">
                <span class="tooltip-text">
                  This is not displayed on Eagle View. Zones are for grouping spots in the system.
                </span>
              </span>
            </label>
            <input id="dockDoorZoneName" type="text" placeholder="(Required) Enter Zone Name" />
          </div>

          <label>Number of Docks:</label>
          <input id="dockDoorCount" type="number" value="3" min="1"/>

          <label>Orientation:</label>
          <select id="dockDoorOrientation">
            <option value="horizontal">Horizontal</option>
            <option value="vertical">Vertical</option>
          </select>

          <label>Show Numbers?</label>
          <select id="dockDoorShowNumbers">
            <option value="yes">Yes</option>
            <option value="no">No</option>
          </select>

          <div id="dockDoorNumbersContainer">
            <label>Start Numbering At:</label>
            <input id="dockDoorStartNumber" type="number" value="1" min="1" />

            <label>Direction of Numbering:</label>
            <select id="dockDoorNumberDirection"></select>

            <label>Label Location:</label>
            <select id="dockDoorLabelLocation"></select>

            <!-- NEW: Label Rotation & Tooltip -->
            <label id="dockDoorLabelRotationLabel" style="display:none;">
              Label Rotation:
              <span class="tooltip-container rotation-tooltip">
                <span class="tooltip-text" id="dockDoorLabelRotationTooltip">
                  Select how labels are rotated.
                </span>
              </span>
            </label>
            <select id="dockDoorLabelRotation" style="display:none;">
              <option value="dynamic">Dynamic</option>
              <option value="90">All 90¬∞</option>
              <option value="none">None</option>
            </select>

            <label>Add Prefix/Suffix?</label>
            <select id="dockDoorPrefixSuffixDropdown">
              <option value="no">No</option>
              <option value="yes">Yes</option>
            </select>

            <div id="dockDoorPrefixSuffixContainer" style="display:none;">
              <label>Dock Prefix:</label>
              <input id="dockDoorPrefix" type="text" placeholder="e.g. D"/>
              <label>Dock Suffix:</label>
              <input id="dockDoorSuffix" type="text" placeholder="e.g. X"/>
            </div>
          </div>

          <button id="addDockDoorsBtn" style="margin-top:1rem;">Add Docks</button>
        </div>
      </div>

      <!-- OTHER ELEMENTS -->
      <div class="menu-section">
        <div class="menu-title" data-target="otherElementsContent">
          <h3>Other Elements</h3><span class="collapse-icon">‚ñº</span>
        </div>
        <div class="menu-content" id="otherElementsContent">
          <label>Element Type:</label>
          <select id="otherElementType">
            <option value="grass">Grass</option>
            <option value="building">Building</option>
            <option value="pavement">Pavement</option>
            <option value="label">Label</option>
            <option value="guard_shack">Guard Shack</option>
            <option value="custom_image">Custom Image</option>
          </select>

          <label id="otherElementWidthLabel">Width:</label>
          <input id="otherElementWidth" type="number" value="50" />
          <label id="otherElementHeightLabel">Height:</label>
          <input id="otherElementHeight" type="number" value="50" />

          <!-- Label Text Field -->
          <label id="labelTextFieldLabel" style="display:none;">Label Text:</label>
          <input 
            id="otherElementLabel"
            type="text"
            placeholder="Type label here"
            style="display:none;"
          />

          <!-- NEW: Font Size Slider (only for label) -->
          <label id="labelFontSizeLabel" style="display:none;">Font Size:</label>
          <input 
            type="range" 
            id="labelFontSizeRange" 
            min="8" 
            max="72" 
            value="16"
            style="display:none; width: 80%;"
          />

          <!-- NEW: Color Selector (only for label) -->
          <label id="labelColorLabel" style="display:none;">Color:</label>
          <select id="labelColorSelect" style="display:none;">
            <option value="#000000">Black</option>
            <option value="#FFFFFF">White</option>
            <option value="#FF0000">Red</option>
            <option value="#00FF00">Green</option>
            <option value="#0000FF">Blue</option>
            <option value="#FFFF00">Yellow</option>
            <option value="#FFA500">Orange</option>
            <option value="#808080">Gray</option>
          </select>

          <!-- NEW: Preview Label -->
          <div 
            id="labelPreviewTitle"
            style="display:none; margin-top:6px; font-weight:bold;"
          >
            Preview
          </div>

          <!-- NEW: Preview Box -->
          <div 
            id="labelPreviewBox"
            style="
              display:none;
              margin-top:4px; 
              border:1px solid #fff; 
              padding:4px; 
              background-color:#A1A3A5; 
              color:#000;
              min-height:30px;
            "
          >
            <!-- Updated dynamically -->
          </div>

          <p id="customImageNote" style="display:none; font-size:0.85rem; color: #ffd700;">
            Image must be JPG, PNG, or SVG file types. Do not upload images larger than 1MB.
          </p>
          <div style="display:flex; align-items:center; gap:0.3rem;">
            <button id="selectImageBtn" style="display:none;">Select Image</button>
            <img id="customImagePreview" alt="Preview" />
          </div>
          <input id="customImageFileInput" type="file" accept=".jpg,.jpeg,.png,.svg" style="display:none;" />

          <button id="addOtherElementBtn">Add Element</button>
        </div>
      </div>

      <!-- ZONES -->
      <div class="menu-section">
        <div class="menu-title" data-target="zonesContent">
          <h3>Zones</h3><span class="collapse-icon">‚ñº</span>
        </div>
        <div class="menu-content" id="zonesContent">
          <div class="zone-name-block">
            <label>Zone Name:</label>
            <input id="zoneName" type="text" placeholder="(Required) Enter Zone Name" />
          </div>

          <label>Number of Spots:</label>
          <input id="zoneSpotCount" type="number" value="5" min="1"/>

          <label>Zone Type:</label>
          <select id="zoneType">
            <option value="horizontal">Horizontal</option>
            <option value="vertical">Vertical</option>
          </select>

          <label style="display: flex; align-items: center; gap: 0.5rem;">
            <input type="checkbox" id="zoneAutoResizeCheckbox" />
            <span>Auto Resize Zone?</span>
          </label>

          <label id="zoneResizeLabel" style="display:none;">Resize every how many spots?</label>
          <input id="zoneResizeCount" type="number" value="10" style="display:none;"/>

          <button id="addZoneBtn">Add Zone</button>
        </div>
      </div>

      <!-- LOST BOX (NEW) -->
      <div class="menu-section">
        <div class="menu-title" data-target="lostBoxContent">
          <h3>Lost Box</h3><span class="collapse-icon">‚ñº</span>
        </div>
        <div class="menu-content" id="lostBoxContent">
          <label>Lost Box Type:</label>
          <select id="lostBoxTypeSelect">
            <option value="wide">Wide</option>
            <option value="tall">Tall</option>
          </select>

          <div class="toggle-section" style="margin-top:1rem;">
            <label for="hideLostBoxToggle">
              Hide Lost Box
              <span class="tooltip-container">
                <span class="tooltip-text">
                  The Lost Box must be present in the final Eagle View. 
                  This option temporarily hides it on the canvas for design flexibility. 
                  The Lost Box will be shown upon export.
                </span>
              </span>
            </label>
            <label class="switch">
              <input type="checkbox" id="hideLostBoxToggle">
              <span class="slider"></span>
            </label>
          </div>
        </div>
      </div>

      <!-- ADVANCED (Scale) -->
      <div class="menu-section"><hr></div>
      <div class="menu-section">
        <div class="menu-title" data-target="advancedMenu">
          <h3>Advanced</h3><span class="collapse-icon">‚ñº</span>
        </div>
        <div class="menu-content" id="advancedMenu">
          <p style="color: #ffd700;">
            Changing the scale will affect layout and may disrupt existing placements.
          </p>
          <label for="canvasScale">Canvas Scale (0.1 - 5.0):</label>
          <input type="number" id="canvasScale" value="1" step="0.1" min="0.1" max="5" />
          <button id="applyScaleBtn">Apply Scale</button>
          <p style="margin-top: 1rem; border-top: 1px solid #999; padding-top: 1rem;">
            <strong>Export IDs</strong>
          </p>
          <p>
            Download an Excel file of all zone and spot IDs.
          </p>
          <button id="exportIdsBtn">Download Excel</button>
        </div>
      </div>

      <!-- IMPORT -->
      <div class="menu-section">
        <div class="menu-title" data-target="importMenu">
          <h3>Import</h3><span class="collapse-icon">‚ñº</span>
        </div>
        <div class="menu-content" id="importMenu">
          <p>Import a previously exported Eagle View SVG to make updates.</p>
          <button id="chooseSvgBtn">Choose SVG</button>
          <input type="file" id="importFileInput" accept=".svg" style="display:none;" />
        </div>
      </div>
    </div>

    <!-- MAIN CONTENT -->
    <div class="main-content">
      <!-- MAIN SVG WRAPPER -->
      <div class="svg-wrapper" id="svgWrapper">
        <!-- Trash Can (HTML element on top) -->
        <div class="trash-can" id="trashCan">
          <img src="https://i.imgur.com/PXejZqX.png" alt="trash can" />
        </div>

        <!-- Our SVG Canvas -->
        <svg 
          id="canvasSVG" 
          width="1046.5" 
          height="500"
          xmlns="http://www.w3.org/2000/svg" 
          xmlns:xlink="http://www.w3.org/1999/xlink"
        >
          <!-- Embed styling in defs so it‚Äôs included in exported SVG -->
          <defs>
            <style><![CDATA[
              text.spot-label {
                fill: #fff;
                font-size: 8.9px;
                font-family: Helvetica, sans-serif;
                pointer-events: none; /* don't intercept clicks */
              }
              .zone-name-box {
                fill: #6A6D6E;
                stroke: #fff;
                stroke-width: 1;
                pointer-events: none;
              }
              .zone-outline {
                fill: transparent;
                stroke: #fff;
                stroke-width: 1;
                pointer-events: none;
              }
              /* Removed fill: #fff from .label-text so color can be overridden by user choice */
              .label-text {
                font-family: Helvetica, sans-serif;
                pointer-events: none;
              }
            ]]></style>
            <pattern 
              id="gridPattern" 
              width="20" 
              height="20" 
              patternUnits="userSpaceOnUse"
            >
              <path d="M20,0 L0,0 0,20" 
                    fill="none" 
                    stroke="#bbb" 
                    stroke-width="1"
                    opacity="0.4" />
            </pattern>
          </defs>

          <!-- Gray background -->
          <rect 
            class="grid-rect"
            x="0" 
            y="0" 
            width="1046.5" 
            height="500" 
            fill="#A1A3A5"
          />

          <!-- Grid overlay rect (for in-app usage, not desired in final exported SVG) -->
          <rect
            class="grid-overlay"
            x="0"
            y="0"
            width="1046.5"
            height="500"
            fill="url(#gridPattern)"
            opacity="1"
          />

          <!-- Draggable items go here -->
          <g id="scalableContent" transform="scale(1)">
          </g>
        </svg>
      </div>

      <!-- NEW FEATURE: Zones Table -->
      <div class="zones-table-wrapper" id="zonesTableWrapper">
        <div class="zones-table-header" id="zonesTableHeader">
          <h3>Zones List</h3>
          <span class="collapse-icon">‚ñº</span>
        </div>
        <div class="zones-table-content" id="zonesTableContent">
          <table id="zonesTable">
            <thead>
              <tr>
                <th>Zone Name</th>
                <th>Zone ID</th>
                <th>Number of Spots / Docks</th>
              </tr>
            </thead>
            <tbody>
              <!-- Zone names will be added here -->
            </tbody>
          </table>
        </div>
      </div>

    </div>

    <!-- Layers Sidebar -->
    <div class="layers-sidebar collapsed" id="layersSidebar">
      <div class="layers-header" id="layersHeader">
        <h3>Layers</h3>
        <span class="collapse-icon" id="layersCollapseIcon">‚ò∞</span>
      </div>
      <ul id="layersList"></ul>
    </div>

  </div> <!-- End of body-wrapper -->

  <!-- FOOTER -->
  <div class="footer">
    Made with ‚òïÔ∏è by
    <a href="https://yardmanagementsoftware.com" target="_blank">Yard Management Solutions</a>
  </div>

  <ul id="layerContextMenu">
    <li data-action="bring-front">Send to Front</li>
    <li data-action="bring-forward">Send Forward</li>
    <li data-action="send-backward">Send Backward</li>
    <li data-action="send-back">Send to Back</li>
  </ul>

  <script>

    // =======================================
    // UNDO / CTRL+Z Support
    // =======================================
    document.addEventListener('keydown', (e) => {
      // Mac users often use metaKey (Command) instead of ctrlKey
      const isUndoKey = (e.ctrlKey || e.metaKey) && e.key === 'z';
      if (isUndoKey) {
        e.preventDefault();
        undoLastAction();
      }
    });
    
    let undoStack = [];

    /**
     * pushUndoAction()
     * 
     * Each action stored in undoStack should have:
     *   {
     *     type: 'move' or 'resize',
     *     element: a reference to the DOM element,
     *     oldX, oldY, oldWidth, oldHeight,  // previous state
     *     newX, newY, newWidth, newHeight   // new state
     *   }
     * 
     * We'll only store what we need for undoing. 
     */
    function pushUndoAction(action) {
      undoStack.push(action);
      updateUndoButtonState();
    }

    /**
     * undoLastAction()
     * 
     * Pops the last action from the stack and reverts it.
     * Then you can optionally push a "redo" action to a redo stack if you want redo support.
     */
    function undoLastAction() {
      if (undoStack.length === 0) {
        return; // nothing to undo
      }

      const action = undoStack.pop();
      if (!action.element) return;

      if (action.type === 'move') {
        // Revert move
        action.element.setAttribute('transform', `translate(${action.oldX},${action.oldY})`);
      } else if (action.type === 'resize') {
        // Revert resize
        updateElementSize(action.element, action.oldWidth, action.oldHeight);
      } else if (action.type === 'delete') {
        // Undo delete by re-inserting the cloned element
        const { element, parent, index, oldX, oldY } = action;
        if (parent && element) {
          const children = Array.from(parent.children);
          if (index >= children.length) {
            parent.appendChild(element);
          } else {
            parent.insertBefore(element, children[index]);
          }
          element.setAttribute('transform', `translate(${oldX},${oldY})`);
          element.setAttribute('data-type', 'draggable');
          element.setAttribute('style', 'cursor: move;');

          // Optionally, update zones and counters
          rebuildZonesTable();
          updateCounters();
        }
      }
      updateUndoButtonState();
    } 

    // =======================================
    // UNDO BUTTON FUNCTIONALITY
    // =======================================

    // Select the Undo button
    const undoBtn = document.getElementById('undoBtn');

    // Check if the button exists to avoid errors
    if (undoBtn) {
      undoBtn.addEventListener('click', () => {
        undoLastAction();
      });
    }

    function updateUndoButtonState() {
      if (undoBtn) {
        if (undoStack.length > 0) {
          undoBtn.disabled = false;
          undoBtn.style.opacity = '1';
          undoBtn.style.cursor = 'pointer';
        } else {
          undoBtn.disabled = true;
          undoBtn.style.opacity = '0.5';
          undoBtn.style.cursor = 'not-allowed';
        }
      }
    }
    updateUndoButtonState();

    // =======================================
    // SIDEBAR COLLAPSE
    // =======================================
    const sidebar = document.getElementById('sidebar');
    const collapseIcon = document.getElementById('collapseIcon');
    const sidebarHeader = sidebar.querySelector('.sidebar-header');
    sidebarHeader.addEventListener('click', () => {
      sidebar.classList.toggle('collapsed');
      collapseIcon.textContent = sidebar.classList.contains('collapsed') ? '‚ò∞' : '‚úï';
    });

    // =======================================
    // COLLAPSIBLE MENUS
    // =======================================
    document.querySelectorAll('.menu-title').forEach(title => {
      title.addEventListener('click', () => {
        const contentId = title.getAttribute('data-target');
        const content = document.getElementById(contentId);
        // Toggle display
        if (content.style.display === 'block') {
          content.style.display = 'none';
          title.querySelector('.collapse-icon').textContent = '‚ñº';
        } else {
          content.style.display = 'block';
          title.querySelector('.collapse-icon').textContent = '‚ñ≤';
        }
      });
    });

    // =======================================
    // SHOW/HIDE LABEL FIELDS FOR "OTHER ELEMENTS"
    //  + CUSTOM IMAGE FIELDS
    // =======================================
    const otherElementType    = document.getElementById('otherElementType');
    const labelTextFieldLabel = document.getElementById('labelTextFieldLabel');
    const otherElementLabel   = document.getElementById('otherElementLabel');
    const otherElementWidthLabel = document.getElementById('otherElementWidthLabel');
    const otherElementHeightLabel= document.getElementById('otherElementHeightLabel');
    const otherElementWidth      = document.getElementById('otherElementWidth');
    const otherElementHeight     = document.getElementById('otherElementHeight');
    const customImageNote        = document.getElementById('customImageNote');
    const selectImageBtn         = document.getElementById('selectImageBtn');
    const customImagePreview     = document.getElementById('customImagePreview');
    const customImageFileInput   = document.getElementById('customImageFileInput');

    // Label-specific elements
    const labelFontSizeLabel    = document.getElementById('labelFontSizeLabel');
    const labelFontSizeRange    = document.getElementById('labelFontSizeRange');
    const labelColorLabel       = document.getElementById('labelColorLabel');
    const labelColorSelect      = document.getElementById('labelColorSelect');
    const labelPreviewTitle     = document.getElementById('labelPreviewTitle');
    const labelPreviewBox       = document.getElementById('labelPreviewBox');

    let customImageData = null;

    function toggleOtherElementFields() {
      const val = otherElementType.value;

      // Label fields
      const isLabelType = (val === 'label');
      labelTextFieldLabel.style.display = isLabelType ? 'block' : 'none';
      otherElementLabel.style.display   = isLabelType ? 'block' : 'none';

      // Hide width/height if label
      otherElementWidthLabel.style.display  = isLabelType ? 'none' : 'block';
      otherElementWidth.style.display       = isLabelType ? 'none' : 'block';
      otherElementHeightLabel.style.display = isLabelType ? 'none' : 'block';
      otherElementHeight.style.display      = isLabelType ? 'none' : 'block';

      // Font size, color, preview
      labelFontSizeLabel.style.display = isLabelType ? 'block' : 'none';
      labelFontSizeRange.style.display = isLabelType ? 'block' : 'none';
      labelColorLabel.style.display    = isLabelType ? 'block' : 'none';
      labelColorSelect.style.display   = isLabelType ? 'block' : 'none';
      labelPreviewTitle.style.display  = isLabelType ? 'block' : 'none';
      labelPreviewBox.style.display    = isLabelType ? 'block' : 'none';

      // Custom Image UI
      const isCustomImage = (val === 'custom_image');
      customImageNote.style.display   = isCustomImage ? 'block' : 'none';
      selectImageBtn.style.display    = isCustomImage ? 'inline-block' : 'none';

      if (!isCustomImage) {
        customImagePreview.style.display = 'none';
        customImagePreview.src = '';
        selectImageBtn.disabled = false;
        customImageData = null;
      }

      // Clear preview if not label
      if (!isLabelType) {
        labelPreviewBox.textContent = '';
      }
    }
    otherElementType.addEventListener('change', toggleOtherElementFields);
    toggleOtherElementFields();

    // Handle file selection for Custom Image
    selectImageBtn.addEventListener('click', () => {
      customImageFileInput.value = ''; // reset
      customImageFileInput.click();
    });

    customImageFileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) {
        customImageData = null;
        return;
      }
      // Basic type check
      const fileName = file.name.toLowerCase();
      if (
        !(
          fileName.endsWith('.jpg') || 
          fileName.endsWith('.jpeg') ||
          fileName.endsWith('.png')  || 
          fileName.endsWith('.svg')
        )
      ) {
        alert('Invalid file type. Please select a JPG, PNG, or SVG.');
        customImageData = null;
        return;
      }

      // Check file size (max 1MB)
      if (file.size > 1024 * 1024) {
        alert('File size exceeds 1MB. Please select a smaller image.');
        customImageData = null;
        return;
      }

      // Read it as a data URL
      const reader = new FileReader();
      reader.onload = function(ev) {
        customImageData = ev.target.result;
        // Display small preview & disable the button
        customImagePreview.src = customImageData;
        customImagePreview.style.display = 'inline-block';
        selectImageBtn.disabled = true;
      };
      reader.readAsDataURL(file);
    });

    // =======================================
    // LIVE PREVIEW FOR LABEL
    // =======================================
    function updateLabelPreview() {
      const text   = otherElementLabel.value || '';
      const size   = labelFontSizeRange.value;
      const color  = labelColorSelect.value;
      labelPreviewBox.style.fontSize = size + 'px';
      labelPreviewBox.style.color    = color;
      labelPreviewBox.textContent    = text;
    }
    otherElementLabel.addEventListener('input', updateLabelPreview);
    labelFontSizeRange.addEventListener('input', updateLabelPreview);
    labelColorSelect.addEventListener('change', updateLabelPreview);
    // Initialize once
    updateLabelPreview();

    // =======================================
    // YARD SPOTS => SHOW/HIDE FIELDS
    // =======================================
    const yardSpotShowNumbers       = document.getElementById('yardSpotShowNumbers');
    const yardSpotNumbersContainer  = document.getElementById('yardSpotNumbersContainer');
    yardSpotShowNumbers.addEventListener('change', () => {
      yardSpotNumbersContainer.style.display = (yardSpotShowNumbers.value === 'yes') ? 'block' : 'none';
      toggleLabelRotationFields(yardSpotShowNumbers.value, 'yardSpotOrientation', 'yardSpotLabelRotation', 'yardSpotLabelRotationTooltip');
    });
    const yardSpotPrefixSuffixDropdown  = document.getElementById('yardSpotPrefixSuffixDropdown');
    const yardSpotPrefixSuffixContainer = document.getElementById('yardSpotPrefixSuffixContainer');
    yardSpotPrefixSuffixDropdown.addEventListener('change', () => {
      yardSpotPrefixSuffixContainer.style.display = (yardSpotPrefixSuffixDropdown.value === 'yes') ? 'block' : 'none';
    });

    // =======================================
    // DOCK DOORS => SHOW/HIDE FIELDS
    // =======================================
    const dockDoorShowNumbers       = document.getElementById('dockDoorShowNumbers');
    const dockDoorNumbersContainer  = document.getElementById('dockDoorNumbersContainer');
    dockDoorShowNumbers.addEventListener('change', () => {
      dockDoorNumbersContainer.style.display = (dockDoorShowNumbers.value === 'yes') ? 'block' : 'none';
      toggleLabelRotationFields(dockDoorShowNumbers.value, 'dockDoorOrientation', 'dockDoorLabelRotation', 'dockDoorLabelRotationTooltip');
    });
    const dockDoorPrefixSuffixDropdown  = document.getElementById('dockDoorPrefixSuffixDropdown');
    const dockDoorPrefixSuffixContainer = document.getElementById('dockDoorPrefixSuffixContainer');
    dockDoorPrefixSuffixDropdown.addEventListener('change', () => {
      dockDoorPrefixSuffixContainer.style.display = (dockDoorPrefixSuffixDropdown.value === 'yes') ? 'block' : 'none';
    });

    // =======================================
    // ORIENTATION => LABEL LOCATION, NUMBER DIRECTION
    // =======================================
    const yardSpotOrientation     = document.getElementById('yardSpotOrientation');
    const yardSpotLabelLocation   = document.getElementById('yardSpotLabelLocation');
    const yardSpotNumberDirection = document.getElementById('yardSpotNumberDirection');
    const dockDoorOrientation     = document.getElementById('dockDoorOrientation');
    const dockDoorLabelLocation   = document.getElementById('dockDoorLabelLocation');
    const dockDoorNumberDirection = document.getElementById('dockDoorNumberDirection');

    function updateLabelLocation(orientation, locationSelect) {
      locationSelect.innerHTML = '';
      if (orientation === 'vertical') {
        locationSelect.add(new Option('Top','top'));
        locationSelect.add(new Option('Bottom','bottom'));
      } else {
        locationSelect.add(new Option('Left','left'));
        locationSelect.add(new Option('Right','right'));
      }
    }
    function updateNumberDirection(orientation, directionSelect) {
      directionSelect.innerHTML = '';
      if (orientation === 'vertical') { // If orientation === 'vertical', we show "Left to Right" and "Right to Left"
        directionSelect.add(new Option('Left to Right','ltr'));
        directionSelect.add(new Option('Right to Left','rtl'));
      } else { // Otherwise (if orientation === 'horizontal'), we show "Top to Bottom" and "Bottom to Top"
        directionSelect.add(new Option('Top to Bottom','ttb'));
        directionSelect.add(new Option('Bottom to Top','btt'));
      }
    }
    function onChangeOrientation(orientationSelect, labelLocSelect, numDirSelect) {
      const orientationVal = orientationSelect.value;
      updateLabelLocation(orientationVal, labelLocSelect);
      updateNumberDirection(orientationVal, numDirSelect);
      toggleLabelRotationFields(
        orientationSelect.id === 'yardSpotOrientation' ? yardSpotShowNumbers.value : dockDoorShowNumbers.value,
        orientationSelect.id, 
        orientationSelect.id === 'yardSpotOrientation' ? 'yardSpotLabelRotation' : 'dockDoorLabelRotation', 
        orientationSelect.id === 'yardSpotOrientation' ? 'yardSpotLabelRotationTooltip' : 'dockDoorLabelRotationTooltip'
      );
    }
    yardSpotOrientation.addEventListener('change', () => {
      onChangeOrientation(yardSpotOrientation, yardSpotLabelLocation, yardSpotNumberDirection);
    });
    dockDoorOrientation.addEventListener('change', () => {
      onChangeOrientation(dockDoorOrientation, dockDoorLabelLocation, dockDoorNumberDirection);
    });
    onChangeOrientation(yardSpotOrientation, yardSpotLabelLocation, yardSpotNumberDirection);
    onChangeOrientation(dockDoorOrientation, dockDoorLabelLocation, dockDoorNumberDirection);

    // =======================================
    // LABEL ROTATION => DESCRIPTIONS AS TOOLTIPS
    // =======================================
    const yardSpotLabelRotation  = document.getElementById('yardSpotLabelRotation');
    const yardSpotLabelRotTooltip   = document.getElementById('yardSpotLabelRotationTooltip');
    const dockDoorLabelRotation  = document.getElementById('dockDoorLabelRotation');
    const dockDoorLabelRotTooltip   = document.getElementById('dockDoorLabelRotationTooltip');

    function updateRotationTooltip(select, tooltipElem) {
      const val = select.value;
      switch(val) {
        case 'none':
          tooltipElem.textContent = 'Labels are never rotated.';
          break;
        case '90':
          tooltipElem.textContent = 'All labels are rotated 90¬∞.';
          break;
        default:
          tooltipElem.textContent = 'Labels rotate only if they have more than 3 characters.';
          break;
      }
    }
    yardSpotLabelRotation.addEventListener('change', () => {
      updateRotationTooltip(yardSpotLabelRotation, yardSpotLabelRotTooltip);
    });
    dockDoorLabelRotation.addEventListener('change', () => {
      updateRotationTooltip(dockDoorLabelRotation, dockDoorLabelRotTooltip);
    });
    updateRotationTooltip(yardSpotLabelRotation, yardSpotLabelRotTooltip);
    updateRotationTooltip(dockDoorLabelRotation, dockDoorLabelRotTooltip);

    function toggleLabelRotationFields(showNumbersVal, orientationId, rotationSelectId, rotationTooltipId) {
      const rotationSelect = document.getElementById(rotationSelectId);
      const rotationTooltip = document.getElementById(rotationTooltipId);
      const orientationSelect = document.getElementById(orientationId);
      if (showNumbersVal === 'yes' && orientationSelect.value === 'vertical') {
        document.getElementById(rotationSelectId + 'Label').style.display = 'block';
        rotationSelect.style.display = 'block';
      } else {
        document.getElementById(rotationSelectId + 'Label').style.display = 'none';
        rotationSelect.style.display = 'none';
      }
      if (showNumbersVal === 'yes' && orientationSelect.value === 'vertical') {
        const currentVal = rotationSelect.value;
        updateRotationTooltip(rotationSelect, rotationTooltip);
      }
    }

    // =======================================
    // ZONES => TOGGLE "RESIZE EVERY X SPOTS?"
    // =======================================
    const zoneAutoResizeCheckbox = document.getElementById('zoneAutoResizeCheckbox');
    const zoneResizeLabel        = document.getElementById('zoneResizeLabel');
    const zoneResizeCount        = document.getElementById('zoneResizeCount');
    zoneAutoResizeCheckbox.addEventListener('change', () => {
      const show = zoneAutoResizeCheckbox.checked;
      zoneResizeLabel.style.display = show ? 'block' : 'none';
      zoneResizeCount.style.display = show ? 'block' : 'none';
    });

    // =======================================
    // STATE VARS
    // =======================================
    let snapToGrid = false;
    let hideTrash  = false;
    let magnetizeEnabled = false;
    let currentScale = 1;

    let facilityId = 1;
    let nextSpotSequence = 1;
    let nextZoneId = 1;
    const zoneNameToIdMap = {};
    let nextLayerId = 1;

    // For Lost Box
    let lostBoxType = 'wide';   // 'wide' or 'tall'
    let lostBoxHidden = false;  // hide on canvas or not
    let lostBoxGroup = null;

    // Initialize facility
    const facilityNumberInput = document.getElementById('facilityNumberInput');
    const startingZoneNumberInput = document.getElementById('startingZoneNumberInput');

    facilityId = parseInt(facilityNumberInput.value, 10) || 1;
    nextZoneId = parseInt(startingZoneNumberInput.value, 10) || 1;

    // Layers sidebar elements - defined early so rebuildLostBox() can access
    const layersSidebar = document.getElementById('layersSidebar');
    const layersHeader = document.getElementById('layersHeader');
    const layersCollapseIcon = document.getElementById('layersCollapseIcon');
    const layersList = document.getElementById('layersList');
    const layerContextMenu = document.getElementById('layerContextMenu');
    let contextTarget = null;

    facilityNumberInput.addEventListener('change', () => {
    facilityId = parseInt(facilityNumberInput.value, 10) || 1;

    // Reassign existing spot IDs to match new facility ID
    reassignSpotIdsForNewFacility(facilityId);

    // Rebuild Lost Box if needed
    rebuildLostBox();
});

    startingZoneNumberInput.addEventListener('change', () => {
    const newStart = parseInt(startingZoneNumberInput.value, 10) || 1;
    reassignZoneIdsForNewStart(newStart);
    });

    function reassignSpotIdsForNewFacility(newFacId) {
      const allSpots = document.querySelectorAll('g.eagleViewDropSpot');

      allSpots.forEach(spot => {
        // Skip the Lost Box if it‚Äôs the lostTrailer
        if (spot.classList.contains('lostTrailer')) return;

        // Retrieve data-sequence
        const seq = spot.getAttribute('data-sequence');
        // If no sequence is found, skip it (or handle older logic differently)
        if (!seq) return;

        // Build the new spot ID
        const newId = buildSpotId(newFacId, seq);
        spot.setAttribute('data-spot-id', newId);

        // Also fix any triangles
        const loadTri = spot.querySelector('[data-loading-id]');
        if (loadTri) {
          loadTri.setAttribute('data-loading-id', newId);
        }
        const unloadTri = spot.querySelector('[data-unloading-id]');
        if (unloadTri) {
          unloadTri.setAttribute('data-unloading-id', newId);
        }
      });
    }

    function reassignZoneIdsForNewStart(newStart) {
      const rows = Array.from(zonesTableBody.querySelectorAll('tr'));

      for (let key in zoneNameToIdMap) {
        delete zoneNameToIdMap[key];
      }

      let currentId = newStart;
      rows.forEach(row => {
        const zoneName = row.children[0].textContent;
        const oldId = row.getAttribute('data-zone-id');

        document.querySelectorAll(`g[data-zone-id="${oldId}"]`).forEach(el => {
          el.setAttribute('data-zone-id', currentId);
        });

        row.setAttribute('data-zone-id', currentId);
        row.children[1].textContent = currentId;

        zoneNameToIdMap[zoneName] = currentId;
        currentId++;
      });

      nextZoneId = currentId;
    }


    function getZoneId(zoneName) {
      if (!zoneNameToIdMap[zoneName]) {
        zoneNameToIdMap[zoneName] = nextZoneId;
        nextZoneId++;
      }
      return zoneNameToIdMap[zoneName];
    }
    function getNextSpotSequence() {
      const seq = nextSpotSequence;
      nextSpotSequence++;
      return seq; // e.g., returns 1, 2, 3, ...
    }
    function buildSpotId(facId, seq) {
      // Convert both to strings and concatenate
      return String(facId) + String(seq);
    }

    // TOGGLES
    const snapToGridToggle = document.getElementById('snapToGridToggle');
    snapToGridToggle.addEventListener('change', () => {
      snapToGrid = snapToGridToggle.checked;
    });
    const hideTrashToggle = document.getElementById('hideTrashToggle');
    hideTrashToggle.addEventListener('change', () => {
      hideTrash = hideTrashToggle.checked;
      toggleTrashCanVisibility(hideTrash);
    });
    function toggleTrashCanVisibility(hide) {
      const trashCan = document.getElementById('trashCan');
      trashCan.style.display = hide ? 'none' : 'block';
    }

    // =======================================
    // LOST BOX
    // =======================================
    const lostBoxTypeSelect = document.getElementById('lostBoxTypeSelect');
    const hideLostBoxToggle = document.getElementById('hideLostBoxToggle');

    lostBoxTypeSelect.addEventListener('change', () => {
      lostBoxType = lostBoxTypeSelect.value;
      rebuildLostBox();
    });
    hideLostBoxToggle.addEventListener('change', () => {
      lostBoxHidden = hideLostBoxToggle.checked;
      if (lostBoxGroup) {
        lostBoxGroup.style.display = lostBoxHidden ? 'none' : '';
      }
    });

    function rebuildLostBox() {
      // Remove the old one, if it exists
      if (lostBoxGroup && lostBoxGroup.parentNode) {
        lostBoxGroup.parentNode.removeChild(lostBoxGroup);
      }
      lostBoxGroup = createLostBoxGroup(lostBoxType, facilityId);
      lostBoxGroup.style.display = lostBoxHidden ? 'none' : '';
      document.getElementById('scalableContent').appendChild(lostBoxGroup);
      assignLayerId(lostBoxGroup);
      rebuildLayersList();
    }

    function createLostBoxGroup(lType, facId) {
      // Dimensions
      // Without top label:
      // wide => w=387, h=54.2
      // tall => w=196.2, h=109.8
      // We'll add 18.2 for the top label bar to final height
      let mainW = 0, mainH = 0, lostClassSuffix = 1;
      if (lType === 'wide') {
        mainW = 387;
        mainH = 54.2;
        lostClassSuffix = 1;
      } else {
        mainW = 196.2;
        mainH = 109.8;
        lostClassSuffix = 2;
      }
      const topLabelH = 18.2;
      const totalH = mainH + topLabelH;

      // Create group
      const group = document.createElementNS('http://www.w3.org/2000/svg','g');
      group.setAttribute('data-type','draggable');
      group.setAttribute('transform', `translate(10, ${500 - totalH - 10})`); // Lost Box shows up on the bottom left by default
      group.setAttribute('data-w', mainW);
      group.setAttribute('data-h', mainH);
      group.setAttribute('x','0');
      group.setAttribute('y', topLabelH);
      // Required classes:
      // droppable eagleViewDropSpot lostTrailer lostX lost_rowY
      // data-spot-id="X000"
      group.setAttribute('class', `droppable eagleViewDropSpot lostTrailer lost${facId} lost_row${lostClassSuffix}`);
      group.setAttribute('data-spot-id', `${facId}000`);

      // Hitbox
      const hitbox = document.createElementNS('http://www.w3.org/2000/svg','rect');
      hitbox.setAttribute('data-role','hitbox');
      hitbox.setAttribute('width', mainW);
      hitbox.setAttribute('height', totalH);
      hitbox.setAttribute('fill','transparent');
      hitbox.setAttribute('pointer-events','fill');
      group.appendChild(hitbox);

      // Top Label rect
      const nameRect = document.createElementNS('http://www.w3.org/2000/svg','rect');
      nameRect.setAttribute('class','zone-name-box');
      nameRect.setAttribute('x','0');
      nameRect.setAttribute('y','0');
      nameRect.setAttribute('width', mainW);
      nameRect.setAttribute('height', topLabelH);
      nameRect.setAttribute('pointer-events','none');
      group.appendChild(nameRect);

      // The text "Lost"
      const nameText = document.createElementNS('http://www.w3.org/2000/svg','text');
      nameText.setAttribute('fill','#fff');
      nameText.setAttribute('font-family','Helvetica, sans-serif');
      nameText.setAttribute('font-size','12');
      nameText.setAttribute('x', mainW/2);
      nameText.setAttribute('y', 13);
      nameText.setAttribute('text-anchor','middle');
      nameText.setAttribute('pointer-events','none');
      nameText.textContent = 'Lost';
      group.appendChild(nameText);

      // Outline for main body (below label)
      const outline = document.createElementNS('http://www.w3.org/2000/svg','rect');
      outline.setAttribute('class','zone-outline');
      outline.setAttribute('x','0');
      outline.setAttribute('y', topLabelH);
      outline.setAttribute('width', mainW);
      outline.setAttribute('height', mainH);
      outline.setAttribute('pointer-events','none');
      group.appendChild(outline);

      // No resize corner, user can only drag

      return group;
    }



    // =======================================
    // SVG WRAPPER & TRASH
    // =======================================
    const svgWrapper = document.getElementById('svgWrapper');
    const canvasSVG  = document.getElementById('canvasSVG');
    const trashCan   = document.getElementById('trashCan');
    const trashImg   = trashCan.querySelector('img');

    // =======================================
    // Zones Table
    // =======================================
    const zonesTableHeader = document.getElementById('zonesTableHeader');
    const zonesTableContent = document.getElementById('zonesTableContent');
    const zonesTableBody    = document.querySelector('#zonesTable tbody');

    zonesTableHeader.addEventListener('click', () => {
      if (zonesTableContent.style.display === 'block') {
        zonesTableContent.style.display = 'none';
        zonesTableHeader.querySelector('.collapse-icon').textContent = '‚ñº';
      } else {
        zonesTableContent.style.display = 'block';
        zonesTableHeader.querySelector('.collapse-icon').textContent = '‚ñ≤';
      }
    });

    function highlightZone(zoneId) {
      const spots = canvasSVG.querySelectorAll(`g.eagleViewDropSpot[data-zone-id="${zoneId}"]`);
      spots.forEach(spot => spot.classList.add('highlighted'));
    }
    function removeHighlightZone(zoneId) {
      const spots = canvasSVG.querySelectorAll(`g.eagleViewDropSpot[data-zone-id="${zoneId}"]`);
      spots.forEach(spot => spot.classList.remove('highlighted'));
    }

    function addZoneToTable(zoneName, zoneId) {
      // 1) Count current total
      const allZoneSpots = canvasSVG.querySelectorAll(
        `g.eagleViewDropSpot[data-zone-id="${zoneId}"]`
      );
      const numberOfSpots = allZoneSpots.length;

      // 2) See if a row for this zone already exists
      const existingRow = zonesTableBody.querySelector(`tr[data-zone-id="${zoneId}"]`);
      if (existingRow) {
        // Update the zone name cell
        existingRow.children[0].textContent = zoneName;
        // existingRow.children[1] is Zone ID cell (unchanged)
        // existingRow.children[2] is "Number of Spots"
        existingRow.children[2].textContent = numberOfSpots;
        updateCounters(); 
        return;
      }

      // 3) Otherwise, create a new row
      const tr = document.createElement('tr');
      tr.setAttribute('data-zone-id', zoneId);

      // (A) Zone Name
      const tdName = document.createElement('td');
      tdName.textContent = zoneName;

      // (B) Zone ID
      const tdId = document.createElement('td');
      tdId.textContent = zoneId;

      // (C) Number of Spots
      const tdCount = document.createElement('td');
      tdCount.textContent = numberOfSpots;

      tr.appendChild(tdName);
      tr.appendChild(tdId);
      tr.appendChild(tdCount);

      zonesTableBody.appendChild(tr);

      // highlight on hover
      tr.addEventListener('mouseover', () => highlightZone(zoneId));
      tr.addEventListener('mouseout', () => removeHighlightZone(zoneId));

      // Update counters after adding a new zone
      updateCounters();
    }


    // =======================================
    // Download Excel of Spot and Zone IDs
    // =======================================

    document.getElementById('exportIdsBtn').addEventListener('click', exportIdsToExcel);

      async function exportIdsToExcel() {
        // 1) Gather data

        // (A) Facility ID
        const facilityID = parseInt(facilityNumberInput.value) || 1;

        // (B) Lost Box ID
        const lostBox = document.querySelector('g.lostTrailer');
        const lostBoxSpotId = lostBox ? lostBox.getAttribute('data-spot-id') : '';

        // (C) Build zoneData object
        const zoneData = {};

        // Collect all droppable spots, skipping the Lost Box
        const allSpots = document.querySelectorAll('g.eagleViewDropSpot');

        allSpots.forEach(spot => {
          // If this is the lost trailer, skip it entirely so we don't get "Zone null"
          // or any unneeded extra sheet
          if (spot.classList.contains('lostTrailer')) {
            return;
          }

          // For everything else, read zone ID and name
          const zId = spot.getAttribute('data-zone-id');
          if (!zId || zId === 'null') {
            // If there's no valid zone ID, skip so we don't create "Zone null" sheets
            return;
          }

          const zName = spot.getAttribute('data-zone-name') || ('Zone ' + zId);

          // For the Spot ID, we might store it as a number if it parses
          let sId = spot.getAttribute('data-spot-id');

          if (!zoneData[zId]) {
            zoneData[zId] = {
              name: zName,
              spotIds: [],
              isDock: false
            };
          }
          zoneData[zId].spotIds.push(sId);

          // Detect dock if triangles
          const hasLoadingTriangle   = spot.querySelector('.loading_triangle');
          const hasUnloadingTriangle = spot.querySelector('.unloading_triangle');
          if (hasLoadingTriangle || hasUnloadingTriangle) {
            zoneData[zId].isDock = true;
          }
        });

        // 2) Build Excel workbook
        const workbook = new ExcelJS.Workbook();

        // -- (Sheet 1) Summary
        const summarySheet = workbook.addWorksheet('Summary');

        // Bold the top row after we add it
        let row = summarySheet.addRow(['Facility ID', facilityID]);
        row.eachCell(cell => (cell.font = { bold: true }));
        // Next row
        row = summarySheet.addRow(['Lost Box Spot ID', lostBoxSpotId]);
        row.eachCell(cell => (cell.font = { bold: true }));

        // Blank line
        summarySheet.addRow([]);

        // Now the summary table header
        let headerRow = summarySheet.addRow(['Zone Name', 'Zone ID']);
        headerRow.eachCell(cell => (cell.font = { bold: true }));

        // Populate zone list
        Object.keys(zoneData).forEach(zId => {
          const zInfo = zoneData[zId];
          // Try to parse zone ID as number
          let numericZId = parseInt(zId, 10);
          if (Number.isNaN(numericZId)) {
            numericZId = zId; // keep it as text if it won't parse
          }
          summarySheet.addRow([zInfo.name, numericZId]);
        });

        // -- (Sheet 2+) One sheet per zone
        Object.keys(zoneData).forEach(zId => {
          const zInfo = zoneData[zId];

          // Make a "safe" sheet name:
          //  - remove invalid chars: :\/?*[] 
          //  - limit to 31 chars
          let safeSheetName = zInfo.name.replace(/[:\\\/\?\*\[\]]/g, '');
          safeSheetName = safeSheetName.substring(0, 31) || 'Zone_' + zId;

          const sheet = workbook.addWorksheet(safeSheetName);

          // Add a header row with bold text
          const zHeaderRow = sheet.addRow(['Spot IDs', 'Docks?']);
          zHeaderRow.eachCell(cell => (cell.font = { bold: true }));

          // For each spot ID in this zone
          zInfo.spotIds.forEach(spotId => {
            // Attempt to store spot ID as number
            let numericSpotId = parseInt(spotId, 10);
            if (Number.isNaN(numericSpotId)) {
              numericSpotId = spotId; // fallback to string if not purely numeric
            }

            sheet.addRow([numericSpotId, zInfo.isDock ? 'Yes' : 'No']);
          });
        });

        // 3) Download as YardIDs.xlsx
        try {
          const buffer = await workbook.xlsx.writeBuffer();
          const blob   = new Blob([buffer], {
            type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
          });
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = 'YardIDs.xlsx';
          link.click();
          URL.revokeObjectURL(url);
        } catch (err) {
          console.error('Export IDs failed:', err);
          alert('Failed to export IDs to Excel. Check console for error details.');
        }
      }




    // =======================================
    // DRAG & RESIZE
    // =======================================
    let currentElement = null;
    let offsetX = 0;
    let offsetY = 0;
    let startWidth = 0;
    let startHeight = 0;
    let startMouseX = 0;
    let startMouseY = 0;
    let isResizing = false;

    canvasSVG.addEventListener('mousedown', (e) => {
      const target = e.target;
      const group = target.closest('g[data-type="draggable"]');
      if (!group) return;

      const [oldX, oldY] = getTranslation(group);
      const oldW = parseFloat(group.getAttribute('data-w')) || 0;
      const oldH = parseFloat(group.getAttribute('data-h')) || 0;

      if (target.hasAttribute('data-resize')) {
        // Resize
        isResizing = true;
        currentElement = group;
        startWidth  = oldW;
        startHeight = oldH;
        startMouseX = e.clientX;
        startMouseY = e.clientY;

        group.__undoData = {
          type: 'resize',
          oldW: oldW,
          oldH: oldH
        };

        e.preventDefault();
        return;
      }

      // Otherwise, drag
      isResizing = false;
      currentElement = group;

      const [curX, curY] = [oldX, oldY];
      offsetX = e.clientX - curX;
      offsetY = e.clientY - curY;

      group.__undoData = {
        type: 'move',
        oldX: oldX,
        oldY: oldY
      };

      e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
      if (!currentElement) return;
      e.preventDefault();

      if (isResizing) {
        const isLabel = !!currentElement.querySelector('[data-role="main"].label-text');
        if (isLabel) {
          // No resizing for labels
          return;
        }

        let dx = e.clientX - startMouseX;
        let dy = e.clientY - startMouseY;
        let newW = startWidth + dx;
        let newH = startHeight + dy;

        if (snapToGrid) {
          const gridSize = 20 * currentScale;
          newW = Math.round(newW / gridSize) * gridSize;
          newH = Math.round(newH / gridSize) * gridSize;
        }
        if (newW < 10) newW = 10;
        if (newH < 10) newH = 10;

        // Maintain aspect ratio if guard shack
        if (currentElement.getAttribute('data-guard') === 'yes') {
          const aspect = startWidth / startHeight;
          if (Math.abs(dx) > Math.abs(dy)) {
            newH = newW / aspect;
          } else {
            newW = newH * aspect;
          }
        }
        updateElementSize(currentElement, newW, newH);

      } else {
        let x = e.clientX - offsetX;
        let y = e.clientY - offsetY;
        if (snapToGrid) {
          const gridSize = 20 * currentScale;
          x = Math.round(x / gridSize) * gridSize;
          y = Math.round(y / gridSize) * gridSize;
        }
        x = Math.max(0, Math.min(x, 1046.5 - 10));
        y = Math.max(0, Math.min(y, 500 - 10));

        if (magnetizeEnabled) {
         [x, y] = magnetizePosition(currentElement, x, y);
        }

        currentElement.setAttribute('transform', `translate(${x},${y})`);
        checkTrashHover(currentElement);
      }
    });

    document.addEventListener('mouseup', () => {
      if (!currentElement) {
        return;
      }
      if (!isResizing) {
        finalizeTrashCheck(currentElement);
      }

      // Check if the element is still in the DOM
      const stillInDOM = canvasSVG.contains(currentElement);

      if (stillInDOM) {
        const [newX, newY] = getTranslation(currentElement);
        const newW = parseFloat(currentElement.getAttribute('data-w')) || 0;
        const newH = parseFloat(currentElement.getAttribute('data-h')) || 0;

        const undoData = currentElement.__undoData;
        if (undoData) {
          // Determine the type of action (move or resize)
          if (undoData.type === 'move') {
            // Push a 'move' action to the undo stack
            pushUndoAction({
              type: 'move',
              element: currentElement,
              oldX: undoData.oldX,
              oldY: undoData.oldY,
              newX: newX,
              newY: newY
            });
          } else if (undoData.type === 'resize') {
            // Push a 'resize' action to the undo stack
            pushUndoAction({
              type: 'resize',
              element: currentElement,
              oldWidth: undoData.oldW,
              oldHeight: undoData.oldH,
              newWidth: newW,
              newHeight: newH
            });
          }
          // Clean up: Remove the temporary undo data
          delete currentElement.__undoData;
        }
      }
      // If the element was deleted (not in DOM), do not push the 'move' action

      currentElement = null;
      isResizing = false;
    });

    function getTranslation(g) {
      const transform = g.getAttribute('transform') || '';
      const match = /translate\(([^,]+),([^)]+)\)/.exec(transform);
      if (match) {
        return [parseFloat(match[1]), parseFloat(match[2])];
      }
      return [0,0];
    }

    function updateElementSize(group, w, h) {
      group.setAttribute('data-w', w);
      group.setAttribute('data-h', h);

      const mainRect  = group.querySelector('rect[data-role="main"]');
      const mainImage = group.querySelector('image[data-role="main"]');
      if (mainRect) {
        mainRect.setAttribute('width', w);
        mainRect.setAttribute('height', h);
      }
      if (mainImage) {
        mainImage.setAttribute('width', w);
        mainImage.setAttribute('height', h);
      }

      const corner = group.querySelector('rect[data-resize="corner"]');
      if (corner) {
        corner.setAttribute('x', w - 12);
        corner.setAttribute('y', h - 12);
      }

      const hitbox = group.querySelector('rect[data-role="hitbox"]');
      if (hitbox) {
        hitbox.setAttribute('width', w);
        hitbox.setAttribute('height', h);
      }
    }

    function checkTrashHover(group) {
      if (hideTrash) return;
      const groupRect = getGlobalBox(group);
      const trashRect = trashCan.getBoundingClientRect();
      if (rectOverlap(groupRect, trashRect)) {
        if (trashImg.src !== 'https://i.imgur.com/jxXQYYR.png') {
          trashImg.src = 'https://i.imgur.com/jxXQYYR.png'; // open
        }
      } else {
        if (trashImg.src !== 'https://i.imgur.com/PXejZqX.png') {
          trashImg.src = 'https://i.imgur.com/PXejZqX.png'; // closed
        }
      }
    }
    function finalizeTrashCheck(group) {
      if (hideTrash) return;
      // Only if the trash can is open
      if (trashImg.src.indexOf('jxXQYYR.png') === -1) return;

      const groupRect = getGlobalBox(group);
      const trashRect = trashCan.getBoundingClientRect();
      if (rectOverlap(groupRect, trashRect)) {
        // Prevent the Lost Box from being trashed
        if (group.classList.contains('lostTrailer')) {
          trashImg.src = 'https://i.imgur.com/PXejZqX.png'; // closed
          return;
        }
        animateTrash();
        createPuff();

        // -- 1) Capture necessary data for undo
        const parent = group.parentNode;
        const siblings = Array.from(parent.children);
        const index = siblings.indexOf(group);
        const clonedGroup = group.cloneNode(true); // Deep clone
        const originalX = group.__undoData ? group.__undoData.oldX : 0;
        const originalY = group.__undoData ? group.__undoData.oldY : 0;


        // -- 2) Push delete action to undoStack
        pushUndoAction({
          type: 'delete',
          element: clonedGroup,
          parent: parent,
          index: index,
          oldX: originalX,
          oldY: originalY
        });

        // -- 3) Remove the group from the DOM
        group.remove();

        // -- 4) Rebuild the Zones List so the row is removed or updated:
        rebuildZonesTable();

        // Update counters after deletion
        updateCounters();

        trashImg.src = 'https://i.imgur.com/PXejZqX.png'; // closed
      }
    }

    function animateTrash() {
      trashCan.classList.add('vibrate');
      setTimeout(() => {
        trashCan.classList.remove('vibrate');
      }, 300);
    }
    function createPuff() {
      const trashRect = trashCan.getBoundingClientRect();
      const puff = document.createElement('div');
      puff.className = 'puff-overlay fade-out';
      puff.style.left = (trashRect.left + window.scrollX) + 'px';
      puff.style.top  = (trashRect.top - 10 + window.scrollY) + 'px';
      puff.textContent= 'üí®';
      document.body.appendChild(puff);
      setTimeout(() => {
        document.body.removeChild(puff);
      }, 800);
    }
    function rectOverlap(r1, r2) {
      return !( r2.left > r1.right ||
                r2.right < r1.left ||
                r2.top > r1.bottom ||
                r2.bottom < r1.top );
    }
    function getGlobalBox(group) {
      const bbox = group.getBBox();
      const ctm  = group.getScreenCTM();
      const p1 = svgPoint(bbox.x, bbox.y, ctm);
      const p2 = svgPoint(bbox.x + bbox.width, bbox.y + bbox.height, ctm);
      return {
        left:   Math.min(p1.x, p2.x),
        top:    Math.min(p1.y, p2.y),
        right:  Math.max(p1.x, p2.x),
        bottom: Math.max(p1.y, p2.y),
      };
    }
    function svgPoint(x, y, matrix) {
      const pt = canvasSVG.createSVGPoint();
      pt.x = x; 
      pt.y = y;
      const transformed = pt.matrixTransform(matrix);
      return { x: transformed.x, y: transformed.y };
    }


    // =======================================
    // ADD SPOTS / DOCK DOORS
    // =======================================
    document.getElementById('addYardSpotsBtn').addEventListener('click', () => {
      const zoneName = document.getElementById('yardSpotZoneName').value.trim();
      if (!zoneName) {
        alert('Please input a Zone Name');
        return;
      }
      const count = parseInt(document.getElementById('yardSpotCount').value, 10) || 1;
      const orientation   = document.getElementById('yardSpotOrientation').value;
      const showNumbers   = document.getElementById('yardSpotShowNumbers').value; 
      const labelRotation = document.getElementById('yardSpotLabelRotation').value;

      let startNumber = 1;
      let prefixSuffixEnabled = false;
      let prefix = '';
      let suffix = '';
      let labelLocation = 'left';
      let numberDirection = 'ttb';

      if (showNumbers === 'yes') {
        startNumber = parseInt(document.getElementById('yardSpotStartNumber').value, 10) || 1;
        prefixSuffixEnabled = (yardSpotPrefixSuffixDropdown.value === 'yes');
        prefix = prefixSuffixEnabled ? document.getElementById('yardSpotPrefix').value : '';
        suffix = prefixSuffixEnabled ? document.getElementById('yardSpotSuffix').value : '';
        labelLocation = document.getElementById('yardSpotLabelLocation').value;
        numberDirection = document.getElementById('yardSpotNumberDirection').value;
      }

      const zoneId = getZoneId(zoneName);
      createLineBasedSpots({
        count, orientation, showNumbers,
        startNumber, prefix, suffix, prefixSuffixEnabled,
        labelLocation, numberDirection, labelRotation,
        zoneName, isDockDoor: false, zoneId
      });

      addZoneToTable(zoneName, zoneId);
    });

    document.getElementById('addDockDoorsBtn').addEventListener('click', () => {
      const zoneName = document.getElementById('dockDoorZoneName').value.trim();
      if (!zoneName) {
        alert('Please input a Zone Name');
        return;
      }
      const count = parseInt(document.getElementById('dockDoorCount').value, 10) || 1;
      const orientation   = document.getElementById('dockDoorOrientation').value;
      const showNumbers   = document.getElementById('dockDoorShowNumbers').value; 
      const labelRotation = document.getElementById('dockDoorLabelRotation').value;

      let startNumber = 1;
      let prefixSuffixEnabled = false;
      let prefix = '';
      let suffix = '';
      let labelLocation = 'left';
      let numberDirection = 'ttb';

      if (showNumbers === 'yes') {
        startNumber = parseInt(document.getElementById('dockDoorStartNumber').value, 10) || 1;
        prefixSuffixEnabled = (dockDoorPrefixSuffixDropdown.value === 'yes');
        prefix = prefixSuffixEnabled ? document.getElementById('dockDoorPrefix').value : '';
        suffix = prefixSuffixEnabled ? document.getElementById('dockDoorSuffix').value : '';
        labelLocation = document.getElementById('dockDoorLabelLocation').value;
        numberDirection = document.getElementById('dockDoorNumberDirection').value;
      }

      const zoneId = getZoneId(zoneName);
      createLineBasedSpots({
        count, orientation, showNumbers,
        startNumber, prefix, suffix, prefixSuffixEnabled,
        labelLocation, numberDirection, labelRotation,
        zoneName, isDockDoor: true, zoneId
      });

      addZoneToTable(zoneName, zoneId);
      updateCounters();
    });

    function buildNumberingArray(opts) {
      const arr = [];
      for (let i = 0; i < opts.count; i++) {
        arr.push(opts.startNumber + i);
      }
      if (opts.orientation === 'vertical' && opts.numberDirection === 'rtl') {
        arr.reverse();
      } else if (opts.orientation === 'horizontal' && opts.numberDirection === 'btt') {
        arr.reverse();
      }
      return arr.map(num => {
        if (!opts.prefixSuffixEnabled) return String(num);
        return opts.prefix + num + opts.suffix;
      });
    }

    function createLineBasedSpots(opts) {
      const zoneId = opts.zoneId;
      const numberingArray = (opts.showNumbers === 'yes')
        ? buildNumberingArray(opts)
        : new Array(opts.count).fill('');

      const container = document.createElementNS('http://www.w3.org/2000/svg','g');
      container.setAttribute('data-type','draggable');
      container.setAttribute('transform','translate(10,10)');
      container.setAttribute('style','cursor: move;');
      container.setAttribute('data-w','0'); 
      container.setAttribute('data-h','0');
      container.setAttribute('data-zone-id', zoneId);
      container.setAttribute('data-zone-name', opts.zoneName);

      let totalW = 0, totalH = 0;
      let offsetX = 0, offsetY = 0;
      const spotW = (opts.orientation === 'horizontal') ? 50.8 : 11.1;
      const spotH = (opts.orientation === 'horizontal') ? 11.1 : 50.8;

      numberingArray.forEach((lbl, index) => {
        if (opts.orientation === 'vertical') {
          const lineLeft = document.createElementNS('http://www.w3.org/2000/svg','line');
          lineLeft.setAttribute('x1', offsetX);
          lineLeft.setAttribute('y1', 0);
          lineLeft.setAttribute('x2', offsetX);
          lineLeft.setAttribute('y2', spotH);
          lineLeft.setAttribute('stroke','#fff');
          lineLeft.setAttribute('stroke-width','1.2');
          lineLeft.setAttribute('pointer-events','none');
          container.appendChild(lineLeft);

          if (index === numberingArray.length - 1) {
            const lineRight = document.createElementNS('http://www.w3.org/2000/svg','line');
            lineRight.setAttribute('x1', offsetX + spotW);
            lineRight.setAttribute('y1', 0);
            lineRight.setAttribute('x2', offsetX + spotW);
            lineRight.setAttribute('y2', spotH);
            lineRight.setAttribute('stroke','#fff');
            lineRight.setAttribute('stroke-width','1.2');
            lineRight.setAttribute('pointer-events','none');
            container.appendChild(lineRight);
          }
          if (opts.showNumbers === 'yes' && lbl) {
            const text = document.createElementNS('http://www.w3.org/2000/svg','text');
            text.setAttribute('class','spot-label');
            text.textContent = lbl;
            text.setAttribute('pointer-events','none');
            positionLabel(text, opts.orientation, opts.labelLocation, spotW, spotH, offsetX, 0, lbl, opts.labelRotation);
            container.appendChild(text);
          }

          const spotGroup = document.createElementNS('http://www.w3.org/2000/svg','g');
          spotGroup.setAttribute('class','droppable eagleViewDropSpot');
          spotGroup.setAttribute('data-zone-name', opts.zoneName);
          spotGroup.setAttribute('data-zone-id', zoneId);
 
              // (1) Get the next sequence
              const seq = getNextSpotSequence();
              spotGroup.setAttribute('data-sequence', seq);

              // (2) Build the actual spot ID from facilityId + sequence
              const spotId = buildSpotId(facilityId, seq);
              spotGroup.setAttribute('data-spot-id', spotId);

          const spotRect = document.createElementNS('http://www.w3.org/2000/svg','rect');
          spotRect.setAttribute('x', offsetX);
          spotRect.setAttribute('y', 0);
          spotRect.setAttribute('width', spotW);
          spotRect.setAttribute('height', spotH);
          spotRect.setAttribute('fill','transparent');
          spotRect.setAttribute('pointer-events','none');
          spotGroup.appendChild(spotRect);

          if (opts.isDockDoor) {
            addDockTriangles(spotGroup, spotId, offsetX, 0, spotW, spotH, opts.labelLocation, opts.orientation);
          }
          container.appendChild(spotGroup);
          offsetX += spotW;
        } else {
          const lineTop = document.createElementNS('http://www.w3.org/2000/svg','line');
          lineTop.setAttribute('x1', 0);
          lineTop.setAttribute('y1', offsetY);
          lineTop.setAttribute('x2', spotW);
          lineTop.setAttribute('y2', offsetY);
          lineTop.setAttribute('stroke','#fff');
          lineTop.setAttribute('stroke-width','1.2');
          lineTop.setAttribute('pointer-events','none');
          container.appendChild(lineTop);

          if (index === numberingArray.length - 1) {
            const lineBottom = document.createElementNS('http://www.w3.org/2000/svg','line');
            lineBottom.setAttribute('x1', 0);
            lineBottom.setAttribute('y1', offsetY + spotH);
            lineBottom.setAttribute('x2', spotW);
            lineBottom.setAttribute('y2', offsetY + spotH);
            lineBottom.setAttribute('stroke','#fff');
            lineBottom.setAttribute('stroke-width','1.2');
            lineBottom.setAttribute('pointer-events','none');
            container.appendChild(lineBottom);
          }
          if (opts.showNumbers === 'yes' && lbl) {
            const text = document.createElementNS('http://www.w3.org/2000/svg','text');
            text.setAttribute('class','spot-label');
            text.textContent = lbl;
            text.setAttribute('pointer-events','none');
            positionLabel(text, opts.orientation, opts.labelLocation, spotW, spotH, 0, offsetY, lbl, opts.labelRotation);
            container.appendChild(text);
          }

          const spotGroup = document.createElementNS('http://www.w3.org/2000/svg','g');
          spotGroup.setAttribute('class','droppable eagleViewDropSpot');
          spotGroup.setAttribute('data-zone-name', opts.zoneName);
          spotGroup.setAttribute('data-zone-id', zoneId);
          
              // (1) Get the next sequence
              const seq = getNextSpotSequence();
              spotGroup.setAttribute('data-sequence', seq);

              // (2) Build the actual spot ID from facilityId + sequence
              const spotId = buildSpotId(facilityId, seq);
              spotGroup.setAttribute('data-spot-id', spotId);

          const spotRect = document.createElementNS('http://www.w3.org/2000/svg','rect');
          spotRect.setAttribute('x', 0);
          spotRect.setAttribute('y', offsetY);
          spotRect.setAttribute('width', spotW);
          spotRect.setAttribute('height', spotH);
          spotRect.setAttribute('fill','transparent');
          spotRect.setAttribute('pointer-events','none');
          spotGroup.appendChild(spotRect);

          if (opts.isDockDoor) {
            addDockTriangles(spotGroup, spotId, 0, offsetY, spotW, spotH, opts.labelLocation, opts.orientation);
          }
          container.appendChild(spotGroup);
          offsetY += spotH;
        }
      });

      if (opts.orientation === 'horizontal') {
        totalW = spotW;
        totalH = opts.count * spotH;
      } else {
        totalW = opts.count * spotW;
        totalH = spotH;
      }

      container.setAttribute('data-w', totalW);
      container.setAttribute('data-h', totalH);

      const containerHitbox = document.createElementNS('http://www.w3.org/2000/svg','rect');
      containerHitbox.setAttribute('data-role','hitbox');
      containerHitbox.setAttribute('width', totalW);
      containerHitbox.setAttribute('height', totalH);
      containerHitbox.setAttribute('fill','transparent');
      containerHitbox.setAttribute('pointer-events','fill');
      container.insertBefore(containerHitbox, container.firstChild);

      document.getElementById('scalableContent').appendChild(container);
      assignLayerId(container);
      rebuildLayersList();
    }

    function addDockTriangles(spotGroup, spotId, x, y, w, h, labelLocation, orientation) {
      let side;
      if (labelLocation === 'left') side = 'right';
      else if (labelLocation === 'right') side = 'left';
      else if (labelLocation === 'top') side = 'bottom';
      else side = 'top';

      const unloadingPoly = document.createElementNS('http://www.w3.org/2000/svg','polygon');
      unloadingPoly.setAttribute('data-unloading-id', spotId);
      unloadingPoly.setAttribute('class','unloading_triangle');
      unloadingPoly.setAttribute('fill', '#30C230');
      unloadingPoly.setAttribute('style','display:none;');
      unloadingPoly.setAttribute('points', getTrianglePoints(side, false, x, y, w, h));

      const loadingPoly = document.createElementNS('http://www.w3.org/2000/svg','polygon');
      loadingPoly.setAttribute('data-loading-id', spotId);
      loadingPoly.setAttribute('class','loading_triangle');
      loadingPoly.setAttribute('fill', '#FFA500');
      loadingPoly.setAttribute('style','display:none;');
      loadingPoly.setAttribute('points', getTrianglePoints(side, true, x, y, w, h));

      spotGroup.appendChild(unloadingPoly);
      spotGroup.appendChild(loadingPoly);
    }

    function getTrianglePoints(side, isLoading, x, y, w, h) {
      const size = 7;
      const half = size / 2;
      const shift = 8 + half; 
      const cx = x + w/2; 
      const cy = y + h/2;
      let p1, p2, p3;

      switch(side) {
        case 'left':
          {
            const cxSide = x - shift;
            if (isLoading) {
              p1 = [cxSide + half, cy];
              p2 = [cxSide - half, cy - half];
              p3 = [cxSide - half, cy + half];
            } else {
              p1 = [cxSide - half, cy];
              p2 = [cxSide + half, cy - half];
              p3 = [cxSide + half, cy + half];
            }
          }
          break;
        case 'right':
          {
            const cxSide = x + w + shift;
            if (isLoading) {
              p1 = [cxSide - half, cy];
              p2 = [cxSide + half, cy - half];
              p3 = [cxSide + half, cy + half];
            } else {
              p1 = [cxSide + half, cy];
              p2 = [cxSide - half, cy - half];
              p3 = [cxSide - half, cy + half];
            }
          }
          break;
        case 'top':
          {
            const cySide = y - shift;
            if (isLoading) {
              p1 = [cx, cySide + half];
              p2 = [cx - half, cySide - half];
              p3 = [cx + half, cySide - half];
            } else {
              p1 = [cx, cySide - half];
              p2 = [cx - half, cySide + half];
              p3 = [cx + half, cySide + half];
            }
          }
          break;
        default:
          {
            const cySide = y + h + shift;
            if (isLoading) {
              p1 = [cx, cySide - half];
              p2 = [cx - half, cySide + half];
              p3 = [cx + half, cySide + half];
            } else {
              p1 = [cx, cySide + half];
              p2 = [cx - half, cySide - half];
              p3 = [cx + half, cySide - half];
            }
          }
          break;
      }
      return `${p1[0]},${p1[1]} ${p2[0]},${p2[1]} ${p3[0]},${p3[1]}`;
    }

    // =======================================
    // positionLabel()
    // =======================================
    function positionLabel(
      label, orientation, labelLocation, w, h,
      offsetX, offsetY, labelText, rotationMode
    ) {
      let shouldRotate = false;
      if (rotationMode === '90') {
        shouldRotate = true;
      } else if (rotationMode === 'dynamic') {
        if (orientation === 'vertical' && labelText && labelText.length >= 3) {
          shouldRotate = true;
        }
      }

      if (!shouldRotate) {
        if (orientation === 'vertical') {
          if (labelLocation === 'top') {
            label.setAttribute('x', offsetX + w/2);
            label.setAttribute('y', -4);
            label.setAttribute('text-anchor','middle');
            label.setAttribute('dominant-baseline','baseline');
          } else {
            label.setAttribute('x', offsetX + w/2);
            label.setAttribute('y', h + 4);
            label.setAttribute('text-anchor','middle');
            label.setAttribute('dominant-baseline','hanging');
          }
        } else {
          if (labelLocation === 'left') {
            label.setAttribute('x', -4);
            label.setAttribute('y', offsetY + h/2);
            label.setAttribute('text-anchor','end');
            label.setAttribute('dominant-baseline','middle');
          } else {
            label.setAttribute('x', w + 4);
            label.setAttribute('y', offsetY + h/2);
            label.setAttribute('dominant-baseline','middle');
          }
        }
      } else {
        const baseOffset = 0;
        const pxPerChar  = 2; 
        const totalWidth = labelText.length * pxPerChar; 
        const offset = baseOffset + totalWidth + 4; 
        const centerX = offsetX + (w / 2) + 1;
        let transformY = 0;
        if (labelLocation === 'top') {
          transformY = -offset;
        } else {
          transformY = h + offset;
        }
        label.setAttribute('transform', `translate(${centerX}, ${transformY}) rotate(-90)`);
        label.setAttribute('text-anchor','middle');
        label.setAttribute('dominant-baseline','middle');
        label.setAttribute('x', 0);
        label.setAttribute('y', 0);
      }
    }

    // =======================================
    // CREATE OTHER ELEMENTS (including Custom Image)
    // =======================================
    document.getElementById('addOtherElementBtn').addEventListener('click', () => {
      const type    = otherElementType.value;
      const labelTxt= otherElementLabel.value || 'Label';
      const fontSize = labelFontSizeRange.value;
      const fontColor= labelColorSelect.value;

      if (type === 'custom_image') {
        if (!customImageData) {
          alert('No image selected or invalid file. Please select a valid JPG, PNG, or SVG.');
          return;
        }
        createCustomImageElement(customImageData);
        customImagePreview.style.display = 'none';
        customImagePreview.src = '';
        selectImageBtn.disabled = false;
        customImageData = null;
        return;
      }

      if (type === 'label') {
        createLabelElement(labelTxt, fontSize, fontColor);
        return;
      }

      const w = +otherElementWidth.value || 50;
      const h = +otherElementHeight.value || 50;
      const group = document.createElementNS('http://www.w3.org/2000/svg','g');
      group.setAttribute('data-type','draggable');
      group.setAttribute('transform','translate(10,10)');
      group.setAttribute('data-w', w);
      group.setAttribute('data-h', h);

      const hitbox = document.createElementNS('http://www.w3.org/2000/svg','rect');
      hitbox.setAttribute('data-role','hitbox');
      hitbox.setAttribute('width', w);
      hitbox.setAttribute('height', h);
      hitbox.setAttribute('fill','transparent');
      hitbox.setAttribute('pointer-events','fill');
      group.appendChild(hitbox);

      if (type === 'guard_shack') {
        const img = document.createElementNS('http://www.w3.org/2000/svg','image');
        img.setAttributeNS('http://www.w3.org/1999/xlink','xlink:href','https://i.imgur.com/cFQFq2L.png');
        img.setAttribute('crossorigin','anonymous'); 
        img.setAttribute('data-role','main');
        img.setAttribute('data-guard','yes');
        img.setAttribute('width', w);
        img.setAttribute('height', h);
        img.setAttribute('pointer-events','none');
        group.appendChild(img);
        addResizeCorner(group, w, h);
      } else {
        const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
        rect.setAttribute('data-role','main');
        rect.setAttribute('width', w);
        rect.setAttribute('height', h);
        rect.setAttribute('pointer-events','none');
        if (type === 'grass') {
          rect.setAttribute('fill','#63954B');
        } else if (type === 'building') {
          rect.setAttribute('fill','#fff');
        } else if (type === 'pavement') {
          rect.setAttribute('fill','#A1A3A5');
        }
        group.appendChild(rect);
        addResizeCorner(group, w, h);
      }

      document.getElementById('scalableContent').appendChild(group);
      assignLayerId(group);
      rebuildLayersList();
    });

    // Dynamically measure text so large labels get a bigger hitbox
    function measureTextSize(text, fontSize) {
      const tempSvg = document.createElementNS('http://www.w3.org/2000/svg','svg');
      const tempText = document.createElementNS('http://www.w3.org/2000/svg','text');
      tempText.setAttribute('font-size', fontSize + 'px');
      tempText.setAttribute('font-family','Helvetica, sans-serif');
      tempText.textContent = text;
      tempSvg.appendChild(tempText);
      document.body.appendChild(tempSvg);
      const bbox = tempText.getBBox();
      document.body.removeChild(tempSvg);
      return { width: bbox.width, height: bbox.height };
    }

    function createLabelElement(text, fontSize, fontColor) {
      // Measure the text so we can set a draggable hitbox that matches.
      const { width, height } = measureTextSize(text, fontSize);

      // Add some margin
      const margin = 10;
      const totalW = width + margin;
      const totalH = height + margin;

      const group = document.createElementNS('http://www.w3.org/2000/svg','g');
      group.setAttribute('data-type','draggable');
      group.setAttribute('transform','translate(10,10)');
      group.setAttribute('data-w', totalW);
      group.setAttribute('data-h', totalH);

      // Hitbox
      const hitbox = document.createElementNS('http://www.w3.org/2000/svg','rect');
      hitbox.setAttribute('data-role','hitbox');
      hitbox.setAttribute('width', totalW);
      hitbox.setAttribute('height', totalH);
      hitbox.setAttribute('fill','transparent');
      hitbox.setAttribute('pointer-events','fill');
      group.appendChild(hitbox);

      // Actual text
      const textEl = document.createElementNS('http://www.w3.org/2000/svg','text');
      textEl.setAttribute('class','label-text');
      textEl.setAttribute('data-role','main');
      textEl.textContent = text;
      // Center the text in the bounding box
      const centerX = totalW / 2;
      const centerY = totalH / 2;
      textEl.setAttribute('x', centerX);
      textEl.setAttribute('y', centerY);
      textEl.setAttribute('text-anchor','middle');
      textEl.setAttribute('dominant-baseline','middle');
      textEl.setAttribute('pointer-events','none');

      // Apply chosen size/color
      textEl.setAttribute('font-size', fontSize + 'px');
      textEl.setAttribute('fill', fontColor);

      group.appendChild(textEl);

      // No resize corner for label
      document.getElementById('scalableContent').appendChild(group);
      assignLayerId(group);
      rebuildLayersList();
    }

    function createCustomImageElement(imageData) {
      const defaultWidth  = 100;
      const defaultHeight = 100;

      const group = document.createElementNS('http://www.w3.org/2000/svg','g');
      group.setAttribute('data-type','draggable');
      group.setAttribute('transform','translate(10,10)');
      group.setAttribute('data-w', defaultWidth);
      group.setAttribute('data-h', defaultHeight);

      const hitbox = document.createElementNS('http://www.w3.org/2000/svg','rect');
      hitbox.setAttribute('data-role','hitbox');
      hitbox.setAttribute('width', defaultWidth);
      hitbox.setAttribute('height', defaultHeight);
      hitbox.setAttribute('fill','transparent');
      hitbox.setAttribute('pointer-events','fill');
      group.appendChild(hitbox);

      const img = document.createElementNS('http://www.w3.org/2000/svg','image');
      img.setAttributeNS('http://www.w3.org/1999/xlink','xlink:href', imageData);
      img.setAttribute('data-role','main');
      img.setAttribute('width', defaultWidth);
      img.setAttribute('height', defaultHeight);
      img.setAttribute('pointer-events','none');
      group.appendChild(img);

      addResizeCorner(group, defaultWidth, defaultHeight);
      document.getElementById('scalableContent').appendChild(group);
      assignLayerId(group);
      rebuildLayersList();
    }

    function addResizeCorner(group, w, h) {
      if (group.getAttribute('data-zone') === 'yes') return;
      const textCheck = group.querySelector('[data-role="main"].label-text');
      if (textCheck) return; // no corner for labels

      const corner = document.createElementNS('http://www.w3.org/2000/svg','rect');
      corner.setAttribute('data-resize','corner');
      corner.setAttribute('width','12');
      corner.setAttribute('height','12');
      corner.setAttribute('fill','transparent');
      corner.setAttribute('pointer-events','fill');
      corner.setAttribute('x', w - 12);
      corner.setAttribute('y', h - 12);
      group.appendChild(corner);
    }

    // =======================================
    // CREATE ZONES (with sub-spots)
    // =======================================
    const zoneSpotCount  = document.getElementById('zoneSpotCount');
    const zoneName       = document.getElementById('zoneName');
    const zoneType       = document.getElementById('zoneType');
    const zoneAutoResize = document.getElementById('zoneAutoResizeCheckbox');
    const zoneResizeCnt  = document.getElementById('zoneResizeCount');
    const addZoneBtn     = document.getElementById('addZoneBtn');

    addZoneBtn.addEventListener('click', () => {
      const zName  = zoneName.value.trim();
      if (!zName) {
        alert('Please input a Zone Name');
        return;
      }

      const spots  = +zoneSpotCount.value || 1;
      const zTypeV = zoneType.value;
      const autoR  = zoneAutoResize.checked;
      const rEvery = +zoneResizeCnt.value || 10;
      const thisZoneId = getZoneId(zName);

      const { zoneW, zoneH, rows, columns } = calculateZoneDimensions(spots, zTypeV, autoR, rEvery);
      const group = document.createElementNS('http://www.w3.org/2000/svg','g');
      group.setAttribute('data-type','draggable');
      group.setAttribute('transform','translate(10,10)');
      group.setAttribute('data-w', zoneW);
      group.setAttribute('data-h', zoneH);
      group.setAttribute('data-zone','yes'); 
      group.setAttribute('data-zone-id', thisZoneId);

      const hitbox = document.createElementNS('http://www.w3.org/2000/svg','rect');
      hitbox.setAttribute('data-role','hitbox');
      hitbox.setAttribute('width', zoneW);
      hitbox.setAttribute('height', zoneH);
      hitbox.setAttribute('fill','transparent');
      hitbox.setAttribute('pointer-events','fill');
      group.appendChild(hitbox);

      const outline = document.createElementNS('http://www.w3.org/2000/svg','rect');
      outline.setAttribute('class','zone-outline');
      outline.setAttribute('data-role','main');
      outline.setAttribute('width', zoneW);
      outline.setAttribute('height', zoneH);
      outline.setAttribute('pointer-events','none');
      group.appendChild(outline);

      const nameRect = document.createElementNS('http://www.w3.org/2000/svg','rect');
      nameRect.setAttribute('class','zone-name-box');
      nameRect.setAttribute('x','0');
      nameRect.setAttribute('y','0');
      nameRect.setAttribute('width', zoneW);
      nameRect.setAttribute('height', '18.2');
      nameRect.setAttribute('pointer-events','none');
      group.appendChild(nameRect);

      const nameText = document.createElementNS('http://www.w3.org/2000/svg','text');
      nameText.setAttribute('fill','#fff');
      nameText.setAttribute('font-family','Helvetica, sans-serif');
      nameText.setAttribute('font-size','12');
      nameText.setAttribute('x', zoneW/2);
      nameText.setAttribute('y', 13);
      nameText.setAttribute('text-anchor','middle');
      nameText.setAttribute('pointer-events','none');
      nameText.textContent = zName;
      group.appendChild(nameText);

      const spotsText = document.createElementNS('http://www.w3.org/2000/svg','text');
      spotsText.setAttribute('fill','#ccc');
      spotsText.setAttribute('font-style','italic');
      spotsText.setAttribute('font-size','12');
      spotsText.setAttribute('font-family','Helvetica, sans-serif');
      spotsText.setAttribute('text-anchor','middle');
      spotsText.setAttribute('data-export-ignore','true');
      spotsText.setAttribute('pointer-events','none');
      const bodyCenterY = (zoneH - 18.2)/2 + 18.2;
      spotsText.setAttribute('x', zoneW/2);
      spotsText.setAttribute('y', bodyCenterY);
      spotsText.textContent = `${spots} Spots`;
      group.appendChild(spotsText);

      // For a "horizontal" Zone, each spot is tall (11.1 wide x 50.8 high).
      // For a "vertical" Zone, each spot is wide (50.8 wide x 11.1 high).
      const subW = (zTypeV === 'horizontal') ? 11.1 : 50.8;
      const subH = (zTypeV === 'horizontal') ? 50.8 : 11.1;

      let yOffset = 18.2;
      for (let r=0; r<rows; r++){
        let xOffset = 0; 
        for (let c=0; c<columns; c++){
          const spotIndex = r*columns + c;
          if (spotIndex >= spots) break;

          const subSpotG = document.createElementNS('http://www.w3.org/2000/svg','g');
          subSpotG.setAttribute('class','droppable eagleViewDropSpot');
          subSpotG.setAttribute('data-zone-name', zName);
          subSpotG.setAttribute('data-zone-id', thisZoneId);
          
          // (1) get the next sequence
          const seq = getNextSpotSequence();
          subSpotG.setAttribute('data-sequence', seq);

          // (2) build spot ID
          const spotId = buildSpotId(facilityId, seq);
          subSpotG.setAttribute('data-spot-id', spotId);

          const subRect = document.createElementNS('http://www.w3.org/2000/svg','rect');
          subRect.setAttribute('x', xOffset);
          subRect.setAttribute('y', 18.2 + (r * subH)); // 18.2 offset for label bar
          subRect.setAttribute('width', subW);
          subRect.setAttribute('height', subH);
          subRect.setAttribute('fill','transparent');
          subRect.setAttribute('pointer-events','none');
          subSpotG.appendChild(subRect);
          group.appendChild(subSpotG);

          xOffset += subW;
        }
        yOffset += subH;
      }

      document.getElementById('scalableContent').appendChild(group);
      assignLayerId(group);
      rebuildLayersList();
      addZoneToTable(zName, thisZoneId);
    });

    function calculateZoneDimensions(spots, zType, autoR, rEvery) {
      // For a "horizontal" zone, each spot is 11.1 wide x 50.8 high
      // For a "vertical" zone, each spot is 50.8 wide x 11.1 high
      const subW = (zType === 'horizontal') ? 11.1 : 50.8;
      const subH = (zType === 'horizontal') ? 50.8 : 11.1;

      let rows = 1;
      let columns = spots;

      if (autoR) {
        // "auto resize" means break the spots into multiple rows once we hit `rEvery`
        if (zType === 'horizontal') {
          // horizontally laid out => chunk columns by rEvery
          columns = Math.min(spots, rEvery);
          rows    = Math.ceil(spots / rEvery);
        } else {
          // vertically laid out => chunk rows by rEvery
          rows    = Math.min(spots, rEvery);
          columns = Math.ceil(spots / rEvery);
        }
      } else {
        if (zType === 'horizontal') {
          // single row, all spots side by side
          columns = spots;
          rows = 1;
        } else {
          // single column, spots stacked vertically
          columns = 1;
          rows = spots;
        }
      }

      // The label bar is ~18.2 tall at the top, so add that to zoneH
      const zoneW = columns * subW;
      const zoneH = rows * subH + 18.2;

      return { zoneW, zoneH, rows, columns, subW, subH };
    }

    // =======================================
    // COUNTERS: Total Spots and Docks (Excluding Lost Box)
    // =======================================

    function updateCounters() {
      // Select all spot groups excluding those with the 'lostTrailer' class
      const allSpots = canvasSVG.querySelectorAll('g.eagleViewDropSpot:not(.lostTrailer)');
      
      // Initialize counters
      let totalSpots = 0;
      let totalDocks = 0;
      
      // Iterate over each spot to determine if it's a dock or a regular spot
      allSpots.forEach(spot => {
        const hasLoadingTriangle = spot.querySelector('.loading_triangle');
        const hasUnloadingTriangle = spot.querySelector('.unloading_triangle');
        
        if (hasLoadingTriangle || hasUnloadingTriangle) {
          // It's a dock
          totalDocks++;
        } else {
          // It's a regular spot
          totalSpots++;
        }
      });
      
      // Update the DOM elements with the new counts
      const totalSpotsElem = document.getElementById('totalSpots');
      const totalDocksElem = document.getElementById('totalDocks');
      
      if (totalSpotsElem) {
        totalSpotsElem.textContent = `Spots: ${totalSpots}`;
      }
      
      if (totalDocksElem) {
        totalDocksElem.textContent = `Docks: ${totalDocks}`;
      }
    }

    // Initial call to set counters on page load
    updateCounters();

    // =======================================
    // Magnetize
    // =======================================
    const magnetizeToggle = document.getElementById('magnetizeToggle');
    magnetizeToggle.addEventListener('change', () => {
      magnetizeEnabled = magnetizeToggle.checked;
    });

    // Helper to parse transform translate(x,y) + w,h from data attributes:
    function getRectFromGroup(g) {
      // Parse the group‚Äôs current transform="translate(X,Y)"
      let transform = g.getAttribute('transform') || '';
      let match = /translate\(([^,]+),\s*([^)]+)\)/.exec(transform);
      let x = 0, y = 0;
      if (match) {
        x = parseFloat(match[1]) || 0;
        y = parseFloat(match[2]) || 0;
      }
      // Then read the stored width/height
      let w = parseFloat(g.getAttribute('data-w')) || 0;
      let h = parseFloat(g.getAttribute('data-h')) || 0;

      return {
        left:   x,
        top:    y,
        right:  x + w,
        bottom: y + h,
        width:  w,
        height: h
      };
    }

    function magnetizePosition(element, proposedX, proposedY) {
      // For the "dragged" element, we know w,h from data-w,data-h
      const eW = parseFloat(element.getAttribute('data-w')) || 0;
      const eH = parseFloat(element.getAttribute('data-h')) || 0;

      // Proposed edges if we place it at (proposedX, proposedY)
      let curLeft   = proposedX;
      let curRight  = proposedX + eW;
      let curTop    = proposedY;
      let curBottom = proposedY + eH;

      const MAGNET_THRESHOLD = 10;

      // Gather all potential snap targets:
      // (If you want *every* draggable object, not just yard spots.)
      const allElements = document.querySelectorAll('g[data-type="draggable"]');

      allElements.forEach((other) => {
        if (other === element) return; // Skip the element we‚Äôre dragging

        const obox = getRectFromGroup(other);

        // Compare left->right
        if (Math.abs(curLeft - obox.right) < MAGNET_THRESHOLD) {
          curLeft = obox.right;
          curRight = obox.right + eW; 
        }
        // Compare right->left
        if (Math.abs(curRight - obox.left) < MAGNET_THRESHOLD) {
          curRight = obox.left;
          curLeft = obox.left - eW;
        }

        // Compare top->bottom
        if (Math.abs(curTop - obox.bottom) < MAGNET_THRESHOLD) {
          curTop = obox.bottom;
          curBottom = obox.bottom + eH;
        }
        // Compare bottom->top
        if (Math.abs(curBottom - obox.top) < MAGNET_THRESHOLD) {
          curBottom = obox.top;
          curTop = obox.top - eH;
        }
      });

      return [curLeft, curTop];
    }


    // =======================================
    // SCALE
    // =======================================
    const applyScaleBtn = document.getElementById('applyScaleBtn');
    applyScaleBtn.addEventListener('click', () => {
      const scaleVal = parseFloat(document.getElementById('canvasScale').value);
      if (isNaN(scaleVal) || scaleVal < 0.1 || scaleVal > 5) {
        alert('Please enter a valid scale between 0.1 and 5.');
        return;
      }
      const sure = confirm('WARNING: Changing the scale will affect layout and may disrupt existing placements. Continue?');
      if (!sure) return;
      document.getElementById('scalableContent').setAttribute('transform', `scale(${scaleVal})`);
      currentScale = scaleVal;
    });

    // =======================================
    // EXPORT (JPG / SVG)
    // =======================================
    const exportJpgBtn = document.getElementById('exportJpgBtn');
    const exportSvgBtn = document.getElementById('exportSvgBtn');
    exportJpgBtn.addEventListener('click', () => {
      exportAsJPG();
    });
    exportSvgBtn.addEventListener('click', () => {
      exportAsSVG();
    });

    async function exportAsJPG() {
      svgWrapper.classList.add('no-border','no-grid','no-buttons','export-cleanup');
      try {
        const canvas = await html2canvas(svgWrapper, {
          backgroundColor: '#A1A3A5',
          width: 1046.5,
          height: 500,
          useCORS: true
        });
        const link = document.createElement('a');
        link.download = 'eagle_view.jpg';
        link.href = canvas.toDataURL('image/jpeg');
        link.click();
      } catch(err) {
        console.error('JPG Export failed:', err);
        alert('Failed to export JPG. Check console for details.');
      } finally {
        svgWrapper.classList.remove('no-border','no-grid','no-buttons','export-cleanup');
      }
    }

    function exportAsSVG() {
      const allLoadingTriangles = document.querySelectorAll('.loading_triangle');
      const allUnloadingTriangles = document.querySelectorAll('.unloading_triangle');
      allLoadingTriangles.forEach(tri => tri.style.display = 'block');
      allUnloadingTriangles.forEach(tri => tri.style.display = 'block');

      const gridOverlay = document.querySelector('.grid-overlay');
      let gridParent = null;
      let gridNextSibling = null;
      if (gridOverlay) {
        gridParent = gridOverlay.parentNode;
        gridNextSibling = gridOverlay.nextSibling;
        gridOverlay.remove();
      }

      canvasSVG.classList.add('export-cleanup','no-grid');
      const draggableGroups = [...document.querySelectorAll('g[data-type="draggable"]')];
      draggableGroups.forEach(g => {
        g.removeAttribute('data-type');
        g.removeAttribute('style');
      });

        // **Hide elements with data-export-ignore by setting inline styles**
        const exportIgnoreElems = canvasSVG.querySelectorAll('[data-export-ignore]');
        exportIgnoreElems.forEach(elem => {
          // Store original display style if needed
          elem.setAttribute('data-original-display', elem.style.display);
          elem.style.display = 'none';
        });

      canvasSVG.setAttribute('data-facility-id', facilityId); // records the Facility ID

      // store layer order
      const groupsForExport = canvasSVG.querySelectorAll('#scalableContent > g');
      groupsForExport.forEach((g, idx) => {
        g.setAttribute('data-layer-index', idx);
      });

      const serializer = new XMLSerializer();
      let source = serializer.serializeToString(canvasSVG);

       // **Restore original display styles**
      exportIgnoreElems.forEach(elem => {
        const originalDisplay = elem.getAttribute('data-original-display');
        elem.style.display = originalDisplay || '';
        elem.removeAttribute('data-original-display');
      });

      canvasSVG.classList.remove('export-cleanup','no-grid');
      if (gridOverlay && gridParent) {
        if (gridNextSibling) {
          gridParent.insertBefore(gridOverlay, gridNextSibling);
        } else {
          gridParent.appendChild(gridOverlay);
        }
      }
      draggableGroups.forEach(g => {
        g.setAttribute('data-type','draggable');
        g.setAttribute('style','cursor: move;');
      });

      if(!source.match(/^<svg[^>]+xmlns="http:\/\/www\.w3\.org\/2000\/svg"/)){
        source = source.replace(
          /^<svg/,
          '<svg xmlns="http://www.w3.org/2000/svg"'
        );
      }
      if(!source.match(/^<svg[^>]+"http:\/\/www\.w3\.org\/1999\/xlink"/)){
        source = source.replace(
          /^<svg/,
          '<svg xmlns:xlink="http://www.w3.org/1999/xlink"'
        );
      }

      const url = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(source);
      const link = document.createElement("a");
      link.href = url;
      link.download = "eagle_view.svg";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);

      allLoadingTriangles.forEach(tri => tri.style.display = 'none');
      allUnloadingTriangles.forEach(tri => tri.style.display = 'none');
    }

    // =======================================
    // IMPORT
    // =======================================
    const chooseSvgBtn = document.getElementById('chooseSvgBtn');
    const importFileInput = document.getElementById('importFileInput');

    chooseSvgBtn.addEventListener('click', () => {
      importFileInput.click();
    });

    importFileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      if (file.type !== 'image/svg+xml') {
        alert('Please select an SVG file.');
        return;
      }
      const reader = new FileReader();
      reader.onload = function(ev) {
        const svgText = ev.target.result;
        parseImportedSVG(svgText);
      };
      reader.readAsText(file);
    });

    function parseImportedSVG(svgText) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(svgText, "image/svg+xml");
      const importedSVG = doc.querySelector("svg");
      if (!importedSVG) {
        alert("No <svg> element found in the selected file.");
        return;
      }
      const importedScalable = importedSVG.querySelector("#scalableContent");
      if (!importedScalable) {
        alert("Could not find <g id='scalableContent'>. Not a valid Eagle View SVG.");
        return;
      }

      const myScalableContent = document.getElementById("scalableContent");
      while (myScalableContent.firstChild) {
        myScalableContent.removeChild(myScalableContent.firstChild);
      }

      while (importedScalable.firstChild) {
        myScalableContent.appendChild(importedScalable.firstChild);
      }

      myScalableContent.querySelectorAll(":scope > g").forEach(g => {
        if (g.hasAttribute("data-w") && g.hasAttribute("data-h")) {
          g.setAttribute("data-type","draggable");
          g.setAttribute("style","cursor: move;");
        }
      });

      const importedFacilityId = importedSVG.getAttribute('data-facility-id');
      if (importedFacilityId) {
        facilityNumberInput.value = importedFacilityId;
        facilityId = parseInt(importedFacilityId, 10) || 1;
        
        // Trigger the 'change' Event to Update Related Elements
        const event = new Event('change');
        facilityNumberInput.dispatchEvent(event);
      }

      const importedTransform = importedScalable.getAttribute("transform");
      if (importedTransform) {
        myScalableContent.setAttribute("transform", importedTransform);
      } else {
        myScalableContent.setAttribute("transform", "scale(1)");
      }

      const allLoadingTriangles = myScalableContent.querySelectorAll('.loading_triangle');
      const allUnloadingTriangles = myScalableContent.querySelectorAll('.unloading_triangle');
      allLoadingTriangles.forEach(tri => (tri.style.display = 'none'));
      allUnloadingTriangles.forEach(tri => (tri.style.display = 'none'));

      // **Reset display for all elements with data-export-ignore without removing the attribute**
      myScalableContent.querySelectorAll('[data-export-ignore]').forEach(el => {
        el.style.display = ''; // Resets to default, making them visible on the canvas
      });

      // **Ensure "X Spots" retain the data-export-ignore attribute to stay hidden during export**
      myScalableContent.querySelectorAll('g.lostTrailer').forEach(el => {
        el.removeAttribute('data-export-ignore', '');
        el.style.display = ''; // Ensure visibility on the canvas
      });

      // **Ensure Only One Lost Box Exists**
      const lostBoxes = myScalableContent.querySelectorAll('g.lostTrailer');
      if (lostBoxes.length > 1) {
        for (let i = 1; i < lostBoxes.length; i++) {
          lostBoxes[i].remove(); // Remove duplicates, keep only the first
        }
      }
      lostBoxGroup = lostBoxes[0] || null; // Reference the remaining Lost Box

      // Sort by stored layer index and assign fresh IDs
      const groupsArr = Array.from(myScalableContent.querySelectorAll(':scope > g'));
      groupsArr.sort((a,b) => {
        return (parseInt(a.getAttribute('data-layer-index')) || 0) -
               (parseInt(b.getAttribute('data-layer-index')) || 0);
      });
      groupsArr.forEach(g => myScalableContent.appendChild(g));
      groupsArr.forEach(assignLayerId);
      rebuildLayersList();

      rebuildZonesTable();
      updateCounters();
      
      alert("SVG import complete! Triangles are hidden, and elements are now on the canvas and editable.");
    }

  function rebuildZonesTable() {
      const myScalableContent = document.getElementById("scalableContent");
      const zoneGroups = myScalableContent.querySelectorAll('g[data-zone-id]');
      zonesTableBody.innerHTML = '';

  // Reset known zoneNameToIdMap so we can repopulate:
  for (let key in zoneNameToIdMap) {
    delete zoneNameToIdMap[key];
  }
  nextZoneId = parseInt(startingZoneNumberInput.value, 10) || 1;
  let smallestZoneId = Infinity;

  zoneGroups.forEach(group => {
    const zoneId = group.getAttribute('data-zone-id');
    const zoneNameAttr = group.getAttribute('data-zone-name');
    
    // Fall back to any existing text if needed, but prefer data-zone-name:
    // (If this is a large "Zone" group, it might have a .zone-name-box + text).
    // But for normal spots, zoneNameAttr is the only reliable value.
    let zoneName = zoneNameAttr 
                   || (group.querySelector('.zone-name-box + text')?.textContent) 
                   || ('Zone ' + zoneId);

    // Store in map
    zoneNameToIdMap[zoneName] = parseInt(zoneId, 10);
    if (parseInt(zoneId, 10) >= nextZoneId) {
      nextZoneId = parseInt(zoneId, 10) + 1;
    }
    if (!isNaN(parseInt(zoneId, 10)) && parseInt(zoneId, 10) < smallestZoneId) {
      smallestZoneId = parseInt(zoneId, 10);
    }
    addZoneToTable(zoneName, zoneId);
  });
  if (zoneGroups.length > 0 && smallestZoneId !== Infinity) {
    startingZoneNumberInput.value = smallestZoneId;
  }
  }

  // ------ Layers Management ------

  layersHeader.addEventListener('click', () => {
    layersSidebar.classList.toggle('collapsed');
    layersCollapseIcon.textContent = layersSidebar.classList.contains('collapsed') ? '‚ò∞' : '‚úï';
  });

  function assignLayerId(el) {
    if (!el.hasAttribute('data-layer-id')) {
      el.setAttribute('data-layer-id', nextLayerId++);
    }
  }

  function getLayerName(g) {
    if (g.classList.contains('eagleViewDropSpot')) {
      return g.getAttribute('data-zone-name') || 'Spot';
    }
    if (g.classList.contains('lostTrailer')) return 'Lost Box';
    if (g.getAttribute('data-zone') === 'yes') {
      const t = g.querySelector('.zone-name-box + text');
      return t ? t.textContent : 'Zone';
    }
    const main = g.querySelector('[data-role="main"]');
    if (main) {
      if (main.tagName === 'image') return 'Custom Image';
      const fill = main.getAttribute('fill');
      if (fill === '#63954B') return 'Grass';
      if (fill === '#fff') return 'Building';
      if (fill === '#A1A3A5') return 'Pavement';
    }
    if (g.querySelector('text')) return 'Label';
    return 'Element';
  }

  function getLayerIcon(g) {
    if (g.classList.contains('eagleViewDropSpot')) {
      return g.querySelector('.loading_triangle') ? 'üö™' : 'üÖøÔ∏è';
    }
    if (g.classList.contains('lostTrailer')) return '‚ùå';
    if (g.getAttribute('data-zone') === 'yes') return 'üì¶';
    const main = g.querySelector('[data-role="main"]');
    if (main) {
      if (main.tagName === 'image') return 'üñºÔ∏è';
      const fill = main.getAttribute('fill');
      if (fill === '#63954B') return 'üå±';
      if (fill === '#fff') return 'üè†';
      if (fill === '#A1A3A5') return '‚¨õ';
    }
    if (g.querySelector('text')) return 'üî§';
    return '‚ùî';
  }

  function rebuildLayersList() {
    layersList.innerHTML = '';
    const groups = document.querySelectorAll('#scalableContent > g');
    groups.forEach((g, idx) => {
      assignLayerId(g);
      g.setAttribute('data-layer-index', idx);
      const li = document.createElement('li');
      li.setAttribute('data-target-id', g.getAttribute('data-layer-id'));
      li.draggable = true;
      li.innerHTML = `<span class="layer-icon">${getLayerIcon(g)}</span><span class="layer-name">${getLayerName(g)}</span>`;
      layersList.appendChild(li);
    });
  }

  let draggedItem = null;
  layersList.addEventListener('dragstart', e => {
    draggedItem = e.target;
    e.target.classList.add('dragging');
  });
  layersList.addEventListener('dragend', e => {
    e.target.classList.remove('dragging');
    updateOrderFromList();
    draggedItem = null;
  });
  layersList.addEventListener('dragover', e => {
    e.preventDefault();
    const li = e.target.closest('li');
    const dragging = document.querySelector('#layersList li.dragging');
    if (!li || !dragging || li === dragging) return;
    const rect = li.getBoundingClientRect();
    const next = (e.clientY - rect.top) > rect.height / 2;
    layersList.insertBefore(dragging, next ? li.nextSibling : li);
  });

  function updateOrderFromList() {
    const order = Array.from(layersList.children).map(li => li.dataset.targetId);
    const scalable = document.getElementById('scalableContent');
    order.forEach(id => {
      const g = scalable.querySelector(`[data-layer-id="${id}"]`);
      if (g) scalable.appendChild(g);
    });
    rebuildLayersList();
  }

  document.getElementById('scalableContent').addEventListener('contextmenu', e => {
    const g = e.target.closest('#scalableContent > g');
    if (!g) return;
    e.preventDefault();
    contextTarget = g;
    layerContextMenu.style.display = 'block';
    layerContextMenu.style.left = e.clientX + 'px';
    layerContextMenu.style.top = e.clientY + 'px';
  });

  document.addEventListener('click', () => {
    layerContextMenu.style.display = 'none';
  });

  layerContextMenu.addEventListener('click', e => {
    const action = e.target.dataset.action;
    if (!action || !contextTarget) return;
    const parent = contextTarget.parentNode;
    if (action === 'bring-front') {
      parent.appendChild(contextTarget);
    } else if (action === 'bring-forward') {
      const next = contextTarget.nextElementSibling;
      if (next) parent.insertBefore(next, contextTarget);
    } else if (action === 'send-backward') {
      const prev = contextTarget.previousElementSibling;
      if (prev) parent.insertBefore(contextTarget, prev);
    } else if (action === 'send-back') {
      parent.insertBefore(contextTarget, parent.firstChild);
    }
    layerContextMenu.style.display = 'none';
    rebuildLayersList();
  });


  rebuildLostBox();
  rebuildLayersList();
  </script>
</body>
</html>
